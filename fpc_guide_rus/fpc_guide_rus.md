[TOC]

# Глава 1

## Вступление.

### 1.1 Об этом документе.

Это руководство пользователя Free Pascal. Он описывает установку и использование компилятора Free Pascal на различных поддерживаемых платформах. Он не пытается дать исчерпывающий список всех поддерживаемых команд, ни определение языка Pascal. Загляните в [Reference Guide](https://www.freepascal.org/docs-html/current/ref/ref.html) для получения более подробных сведений об этих вещах. Описание возможностей и внутренней работы компилятора см. в [Programmer’s Guide](https://www.freepascal.org/docs-html/current/prog/prog.html). В приложениях этого документа вы найдете списки зарезервированных слов и сообщения об ошибках компилятора (с описаниями).

Этот документ описывает компилятор как он есть/функционирует на момент написания. Сначала обратитесь к файлам README и FAQ, которые распространяются вместе с компилятором. Файлы README и FAQ, в случае конфликта с данным руководством, являются официальными.

### 1.2 О компиляторе.

Free Pascal - это 32- и 64-битный компилятор Pascal. Текущая версия (2.6) может компилировать код для следующих процессоров:

- Intel i386 и выше (i486, семейство Pentium и выше)
- AMD64/x86_64
- PowerPC
- PowerPC64
- SPARC
- ARM
- Процессор m68K поддерживается более старой версией

Компилятор и библиотека времени выполнения доступны для следующих операционных систем:

- DOS

- LINUX

- AMIGA (только для версии 0.99.5)

- WINDOWS

- Mac OS X

- OS/2 (опционально, используя пакет EMX, поэтому он также работает на DOS/Windows)

- FREEBSD

- BEOS

- SOLARIS

- NETBSD

- NETWARE

- OPENBSD

- MorphOS

- Symbian

  

Полный список всегда доступен на сайте Free Pascal.

Free Pascal предназначен для максимально возможной совместимости исходного кода с Turbo Pascal 7.0 и Delphi 7 (хотя эта цель еще не достигнута), но он также расширяет эти языки с помощью таких элементов, как перегрузка операторов. И, в отличие от этих предков, он поддерживает несколько платформ.

Он также отличается от них тем, что вы не можете использовать скомпилированные модули из одной системы для другой, то есть вы не можете использовать скомпилированные модули TP.

Кроме того, для Free Pascal доступна текстовая версия интегрированной среды разработки (IDE). Пользователи, которые предпочитают графическую среду разработки, могут взглянуть на проекты [Lazarus](https://www.lazarus-ide.org) или [MSEIDE](https://mseide-msegui.sourceforge.io).

Free Pascal состоит из нескольких частей:

1. Сама программа компилятора.
2. Библиотека времени выполнения (RTL).
3. Пакеты. Это набор из множества служебных модулей, начиная от всего API-интерфейса Windows 32 и заканчивая обработкой файлов ZIP/BZIP до всего интерфейса GTK-2.
4. Библиотека бесплатных компонентов. Это набор утилит на основе классов, которые предоставляют структуру базы данных, поддержку изображений, веб-поддержку, поддержку XML и многое другое.
5. Программы-утилиты и модули.

Из них вам нужны только первые два, чтобы иметь возможность использовать компилятор. В этом документе мы опишем использование компилятора и утилит. Язык Pascal описан в [Reference Guide](https://www.freepascal.org/docs-html/current/ref/ref.html), а доступные подпрограммы (блоки) описаны в справочных руководствах по RTL и FCL.



### 1.3 Получение дополнительной информации.

 Если документация не дает ответа на ваши вопросы, вы можете получить дополнительную информацию в Интернете по следующим адресам:

- [http://www.freepascal.org/](http://www.freepascal.org/)- это основной сайт. Он также содержит полезные почтовые адреса и ссылки на другие места. Он также содержит инструкции по подписке на *список рассылки*.

- [http://forum.lazarus.freepascal.org/](http://forum.lazarus.freepascal.org/)- это форум, на котором можно публиковать вопросы.



Помимо этого, существуют некоторые зеркала.

Наконец, если вы считаете, что что-то должно быть добавлено в это руководство (вполне возможно), пожалуйста, не стесняйтесь и свяжитесь со мной по адресу [michael@freepascal.org](mailto:michael@freepascal.org).

Давайте продолжим с чего-нибудь полезного.



# Глава 2

## Установка компилятора.

### 2.1 Перед установкой: требования.

#### 2.1.1 Требования к оборудованию

Компилятору нужен хотя бы один из следующих процессоров: 

1. Процессор Intel 80386 или выше. Сопроцессор не требуется, хотя это и замедлит работу вашей программы, если вы будете выполнять вычисления с плавающей запятой без сопроцессора, поскольку будет использоваться эмуляция.
2. Процессор AMD64 или EMT64.
3. Процессор PowerPC.
4. Процессор SPARC.
5. Процессор ARM.
6. Более старые версии FPC существуют для процессора Motorola 68000, но они больше не поддерживаются.

Требования к памяти и диску:

1. 8 мегабайт свободной памяти. Этого достаточно для компиляции небольших программ.

2. Для больших программ (таких как сам компилятор) потребуется не менее 64 МБ. памяти, но рекомендуется 128 МБ. (Обратите внимание, что самим скомпилированным программам не нужно так много памяти.)

3. Не менее 80 МБ свободного дискового пространства. Когда источники установлены, требуется еще 270 МБ.

   

#### 2.1.2 Требования к программному обеспечению

##### Под DOS

Дистрибутив DOS содержит все файлы, необходимые для запуска компилятора и компиляции программ на Pascal. 

##### Под UNIX

В системах UNIX (таких как LINUX) вам необходимо установить следующие программы:

1. GNU **as**, сборщик GNU.

2. GNU **ld**, компоновщик GNU.

3. Необязательно (но настоятельно рекомендуется): GNU **make**. Для легкой перекомпиляции компилятора и библиотеки времени выполнения это необходимо.

##### Под Windows

 Дистрибутивы WINDOWS (32- и 64-битные) содержат все файлы, необходимые для запуска компилятора и компиляции программ на Pascal. Тем не менее, было бы неплохой идеей установить дополнительно инструменты [**mingw32**](https://osdn.net/projects/mingw/releases/p15608)(svn зеркала: [binw32](https://svn.freepascal.org/svn/fpcbuild/trunk/install/binw32/) и [binw64](https://svn.freepascal.org/svn/fpcbuild/trunk/install/binw64/)) или инструмент разработки [**cygwin**](https://www.cygwin.com/). Ссылки на оба эти инструмента можно найти на [https://www.freepascal.org](https://www.freepascal.org/) (*прим.перев*.: так в оригинальном документе. Увы, в настоящее время по этой ссылке я их там не нашел).

##### Под OS/2

Несмотря на то, что в дистрибутив Free Pascal входят все необходимые инструменты, рекомендуется установить расширение EMX, чтобы компилировать и запускать программы с помощью компилятора Free Pascal. Расширение EMX можно найти на: [ftp://hobbes.nmsu.edu/pub/os2/dev/emx/v0.9d](ftp://hobbes.nmsu.edu/pub/os2/dev/emx/v0.9d) 

##### Под Mac OS X

Mac OS X 10.1 or higher is required, and the developer tools or XCode should be installed.

 Требуется Mac OS X 10.1 или выше, и должны быть установлены developer tools (инструменты разработчика) или XCode.



### 2.2 Установка компилятора.

Установка Free Pascal проста, но зависит от платформы. Мы обсудим процесс для каждой платформы отдельно.



#### 2.2.1 Установка под Windows.

Для WINDOWS есть установщик WINDOWS, *setup.exe*. Это обычная программа установки, которая предлагает обычные варианты выбора каталога и какие части дистрибутива вы хотите установить. При необходимости он будет связывать расширения *.pp* или *.pas* с IDE текстового режима. 

Не рекомендуется устанавливать компилятор в каталог с пробелами в имени пути. Некоторые из внешних инструментов не поддерживают имена файлов с пробелами в них, и у вас будут проблемы при создании программ.



#### 2.2.2 Установка под DOS или OS/2.

##### Обязательные этапы установки.

Во-первых, вы должны получить последние дистрибутивы Free Pascal. Они приходят в виде zip-файлов, которые вы должны сначала распаковать, или вы можете скачать компилятор как серию отдельных файлов. Это особенно полезно, если у вас медленное соединение, но также хорошо, если вы хотите установить только некоторые части дистрибутива компилятора. Распространяемые zip-файлы для DOS или OS/2 содержат программу установки INSTALL.EXE. Вы должны запустить эту программу для установки компилятора. 

Экран программы установки DOS или OS/2 выглядит как на рисунке 2.1. 

|        ![](pictures/fig_2_1_dos_install.png)        |
| :----------------------------------------: |
| рисунок 2.1: Скрин установки программы DOS |

Программа позволяет выбрать:

- какие компоненты вы хотите установить, например, хотите ли вы установить исходники или нет, хотите ли установить документы или нет. Элементы, которые вы не собирались загружать в виде отдельных файлов, не будут доступны для пометки, то есть вы не можете выбрать их.
- куда вы хотите их установить (по умолчанию это `C:\PP`).

Чтобы запустить Free Pascal из любого каталога в вашей системе, вы должны расширить переменную path так, чтобы она содержала путь к каталогу `C:\PP\BIN`. Обычно это делается в файле *AUTOEXEC.BAT*. Это должно выглядеть примерно так:

```bash
SET PATH=%PATH%;C:\PP\2.6\BIN\i386-DOS
```

для DOS или

```bash
SET PATH=%PATH%;C:\PP\2.6\BIN\i386-OS2
```

для OS/2 (опять же, при условии, что вы установили fpc в папку по умолчанию).

В OS/2 Free Pascal устанавливает некоторые библиотеки из пакета EMX, если они еще не установлены (инсталлятор уведомит вас, если они должны быть установлены). Они расположены в папке 

```bash
C:\PP\DLL
```

Имя этого каталога должно быть добавлено в директиву **LIBPATH** в файле *config.sys*:

```bash
LIBPATH=XXX;C:\PP\DLL
```

Очевидно, что любые существующие каталоги в директиве **LIBPATH** (обозначенные **XXX** в приведенном выше примере) должны быть сохранены.

| ![](pictures/fig_2_2_dos_install.png) |
| :--------------------------: |
|         Рисунок 2.2          |

##### Дополнительная установка: эмуляция сопроцессора.

Для тех, у кого более старый тип процессора без математического сопроцессора (i387), необходимо установить эмуляцию сопроцессора, поскольку Free Pascal использует сопроцессор для выполнения всех операций с плавающей точкой. 

Установка эмуляции сопроцессора выполняется программой установки (*INSTALL.EXE*) в DOS и WINDOWS.


#### 2.2.3 Установка под Linux.

##### Обязательные этапы установки.

Дистрибутив Free Pascal для LINUX представлен в трех формах:

- версия **tar.gz**, также доступная в виде отдельных файлов
- версия **.rpm** (Red Hat Package Manager) и
- версия **.deb** (Debian).

Если вы используете формат *.rpm*, для установки достаточно

```bash
rpm -i fpc-X.Y.Z-N.ARCH.rpm
```

где **X**.**Y**.**Z** - номер версии файла *.rpm*, а **ARCH** - одна из поддерживаемых архитектур процессора (i386, x86_64 и т.д.).

Если вы используете Debian, для установки достаточно

```bash
dpkg -i fpc-XXX.deb
```

Опять же, здесь **XXX** - номер версии файла *.deb*.



Вам нужен root-доступ для установки этих пакетов. Файл *.tar* позволяет выполнить установку в домашним каталог, если у вас нет прав root.

При загрузке файла *.tar* или отдельных файлов установка более интерактивная. В случае, если вы загрузили файл *.tar*, вы должны сначала распаковать его в произвольный каталог, где у вас есть разрешение на запись, используя следующую команду:

```bash
tar -xvf fpc.tar
```

Подразумевается, что вы заранее скачали файл *fpc.tar* откуда-то из Интернета (реальное имя файла будет иметь определенный номер версии, который мы здесь не упоминаем для простоты понимания процесса установки). 

Когда файл распакуется, у вас появится большое количество файлов архивов и программа-установщик: командный скрипт установки.

Если вы загрузили файлы как отдельные файлы, вы должны как минимум скачать скрипт установки *install.sh* и библиотеки (в *libs.tar.gz*).

Чтобы установить Free Pascal, все, что вам нужно сделать сейчас, это задать в терминале следующую команду:

```bash
./install.sh
```

И тогда вы должны будете ответить на несколько вопросов. Они очень простые, в основном они касаются двух вещей:

1. мест, куда можно устанавливать разные вещи
2. решения, хотите ли вы установить определенные компоненты (например, исходные коды и демо-программы)

Скрипт автоматически определит, какие компоненты присутствуют и могут быть установлены. Он будет предлагать только установить то, что было найдено. Из-за этой функции вы должны сохранять исходные имена при загрузке, так как сценарий ожидает этого.

Если вы запускаете скрипт установки от имени пользователя root, вы можете просто принять все установки по умолчанию. Если вы запускаете не от имени пользователя root, вы должны позаботиться о том, чтобы предоставить программе установки имена каталогов, для которых у вас есть разрешение на запись, поскольку установщик попытается создать указанные вами каталоги. В принципе, вы можете установить компилятор, кудаугодно.

В конце установки инсталлятор сгенерирует файл конфигурации (*fpc.cfg*) для компилятора Free Pascal, в котором будут отражены выбранные вами настройки. Он установит этот файл в каталог `/etc` или в ваш домашний каталог (с именем *.fpc.cfg*), если у вас нет разрешения на запись в каталог `/etc`. Он сделает копию в каталоге, куда вы установили библиотеки.

Компилятор сначала ищет файл *.fpc.cfg* в вашем домашнем каталоге, а затем ищет в каталоге `/etc`.



### 2.3 Необязательные этапы настройки.

На любой платформе после установки компилятора вы можете установить некоторые переменные окружения. Компилятор Free Pascal распознает следующие переменные:

- **PPC_EXEC_PATH** содержит каталог, в котором можно найти файлы поддержки для компилятора.
- **PPC_CONFIG_PATH** указывает альтернативный путь для поиска fpc.cfg.
- **PPC_ERROR_FILE** указывает путь и имя файла определения ошибки.
- **FPCDIR** указывает корневой каталог установки Free Pascal (например: **C:\PP\BIN**)

Однако эти местоположения задаются в примере файла конфигурации, который создается в конце процесса установки, за исключением переменной **PPC_CONFIG_PATH**, которую необходимо установить, если вы не устанавливали компоненты компилятора в местах по умолчанию.



### 2.4 Перед началом компиляции.

Также с Free Pascal распространяется файл *README*. Он содержит последние инструкции по установке Free Pascal, и его всегда следует читать в первую очередь.

Кроме того, информация о платформе и общие вопросы рассматриваются в *FAQ*. Его также следует прочитать прежде, чем сообщать о любой ошибке.



### 2.5 Тестирование компилятора.

После завершения установки и задания необязательных переменных окружения, как описано выше, ваша первая программа может быть скомпилирована. 

В дистрибутив Free Pascal включены некоторые демонстрационные программы, показывающие, что может делать компилятор. Вы можете проверить, правильно ли работает компилятор, попытавшись скомпилировать эти программы.

Компилятором называется файл

- *fpc.exe* под WINDOWS, OS/2 и DOS.
- *fpc* под большинством других операционных систем.

Чтобы скомпилировать программу (например, *demo\text\hello.pp*), скопируйте программу в текущий рабочий каталог и просто напечатайте 

в командной строке. Если у вас нет файла конфигурации, вам может потребоваться указать компилятору, где он может найти модули, например, следующим образом:

```bash
fpc hello
```

в командной строке. Если у вас нет файла конфигурации, вам может потребоваться указать компилятору, где он может найти модули, например, следующим образом:

```bash
fpc -Fuc:\pp\NNN\units\i386-go32v2\rtl hello
```

под DOS и под Linux вы можете набрать

```bash
fpc -Fu/usr/lib/fpc/NNN/units/i386-linux/rtl hello
```

(замените NNN на номер версии Free Pascal, который вы используете). Это, конечно, при условии, что вы установили его в `C:\PP` или `/usr/lib/fpc/NNN`, соответственно. 

Если вы не получили сообщений об ошибках, компилятор сгенерировал исполняемый файл *hello.exe* в DOS, OS/2 или WINDOWS или *hello* (без расширения) в UNIX и большинстве других операционных систем.

Чтобы выполнить программу, просто введите:

```bash
hello
```

или

```bash
./hello
```

в никсах (где текущий каталог обычно отсутствует в **PATH**). Если все прошло хорошо, вы должны увидеть следующее дружеское приветствие:

```bash
Hello world
```



# Глава 3

## Использование компилятора.

Здесь мы опишем основы для компиляции программы и модуля. Более подробное использование компилятора см. в разделе о настройке компилятора и [Programmer’s Guide](https://www.freepascal.org/docs-html/current/prog/prog.html). 

Примеры в этом разделе предполагают, что у вас есть fpc.cfg, который настроен правильно и который содержит по крайней мере настройку пути для модулей RTL. В принципе этот файл генерируется программой установки. Возможно, вам придется проверить, что это в правильном месте. (см. раздел [5.2](###5.2-Использование-файла конфигурации) для получения дополнительной информации об этом.)



### 3.1 Поиск файлов.

Перед тем, как начать компилировать программу или серию модулей, важно знать, где компилятор ищет свои исходные файлы и другие файлы. В этом разделе мы обсудим это и укажем, как на это повлиять.

**Примечание.** Использование прямых слэшей (/) и обратных слэшей (\\) в качестве разделителей каталогов не имеет значения, компилятор преобразует их в любой символ, используемый в текущей операционной системе. Примеры будут приведены с использованием прямого слэша, поскольку это позволяет избежать проблем в системах Unix (таких как Linux).

#### 3.1.1 Файлы командной строки.

Файл, который вы указываете в командной строке, например, в

```bash
FPC foo.pp
```

компилятор будет искать файл ТОЛЬКО в текущем каталоге. Если вы укажете каталог в имени файла:

```bash
fpc subdir/foo.pp
```

то компилятор будет искать *foo.pp* в подкаталоге `subdir` текущего каталога.

В чувствительных к регистру файловых системах (таких как linux и unix) имя этого файла чувствительно к регистру; в других операционных системах (таких как DOS, Windows NT, OS/2) - нет.



#### 3.1.2. Модули файлов

Когда вы компилируете модуль или программу, которой нужны другие модули, компилятор будет искать скомпилированные версии этих модулей следующим образом:

- Он будет выглядеть в текущем каталоге.

- Он будет смотреть в каталоге, где находится исходный файл.

- Он будет искать в каталоге, где находится двоичный файл компилятора.

- Он будет смотреть во всех каталогах, указанных в пути поиска модуля.



Вы можете добавить каталог в путь поиска устройства с помощью опции (**-Fu** (см. раздел [5.1.3](####5.1.3-Опции,-касающиеся-файлов-и-каталогов))). При каждом появлении одной из этих опций каталог вставляется в путь поиска объекта, т.е. последний путь в командной строке будет искаться первым.

Компилятор добавляет несколько путей к пути поиска модуля:

1. Содержимое переменной среды XXUNITS, где XX необходимо заменить одной из поддерживаемых целей: GO32V2, LINUX, WIN32, OS2, BEOS, FREEBSD, SUNOS, DARWIN (фактический список зависит от доступных целей).

2. Стандартная каталог модуля. Этот каталог определяется из переменной среды **FPCDIR**. Если эта переменная не задана, по умолчанию используется следующее:

- в linux:

  ```bash
  /usr/local/lib/fpc/FPCVERSION
  ```

  или

  ```bash
  /usr/lib/fpc/FPCVERSION
  ```

- в других ОС: каталог с бинарником компилятора, с добавленным к нему "./", если он существует. Например, в Windows это будет означать:

```bash
C:\FPC\2.6\units\i386-win32
```

Это при условии, что компилятор был установлен в каталоге

```bash
C:\FPC\2.6
```



После определения этого каталога к пути поиска добавляются следующие пути:

```bash
FPCDIR/units/FPCTARGET
```

```bash
FPCDIR/units/FPCTARGET/rtl
```



Здесь цель должна быть заменена именем цели, для которой вы компилируете: это комбинация процессора и ОС, например, так

```bash
/usr/local/lib/fpc/2.6/units/i386-linux/
```

или при кросс-компиляции

```bash
/usr/local/lib/fpc/2.6/units/i386-win32/
```



Опция **-Fu** принимает один подстановочный знак *****, который будет заменен всеми каталогами, найденными в этом месте, но не самим местоположением. Например, с учетом каталогов

```bash
rtl/units/i386-linux
```
```bash
fcl/units/i386-linux
```
```bash
packages/base
```
```bash
packages/extra 
```

команда

```bash
fpc -Fu"*/units/i386-linux"
```

будет иметь тот же эффект, что и
```bash
fpc -Furtl/units/i386-linux -Fufcl/units/i386-linux
```
поскольку каталоги `rtl` и `fcl` содержат дополнительные подкаталоги  `units/i386-linux`. Каталог пакетов не будет добавлен, так как он не содержит подкаталог `units/i386-linux`.



Следующая команда
```bash
fpc -Fu"units/i386-linux/*"
```
будет соответствовать любому каталогу в каталоге `units/i386-linux`, но не будет совпадать с самим каталогом `units/i386-linux`, поэтому вы должны добавить его вручную, если вы хотите, чтобы компилятор также искал файлы в этом каталоге:

```bash
fpc -Fu"units/i386-linux" -Fu"units/i386-linux/*"
```


Обратите внимание, что (для оптимизации) компилятор удалит любые несуществующие пути из пути поиска, то есть будет проверено существование пути (после раскрытия подстановочного знака ***** и изменения переменной среды).

Вы можете увидеть, какие пути будет искать компилятор, задав компилятору опцию **-vu**.

Обратите внимание, что пути файла модуля, указанные в файле конфигурации, будут добавлены в конце, а пути, указанные в командной строке, будут добавлены в начале.

Представьте себе следующую командную строку:
```bash
fpc -n -Fu/home @cfg -Fu/usr foo.pp
```
Где файл *cfg* имеет следующее содержимое:
```bash
-Fu/etc
```
Это приведет к следующему пути поиска

- Используемый путь модуля: `/home/`
- Используемый путь модуля: `/usr/`
- Используемый путь модуля: `/etc/`
- Используемый путь модуля: `/data/FPC/installed/3.1.1/`



Изменение порядка файлов в командной строке:
```bash
fpc -n -Fu/usr @cfg -Fu/home foo.pp
```
в результате:

- Используемый путь модуля: `/usr/`
- Используемый путь модуля: `/home/`
- Используемый путь модуля: `/etc/`
- Используемый путь модуля: `/data/FPC/installed/3.1.1/`



Перемещение позиции @cfg не изменит путь:

```bash
fpc -n @cfg -Fu/home -Fu/usr foo.pp
```
в результате:
- Используемый путь модуля: `/home/`
- Используемый путь модуля: `/usr/`
- Используемый путь модуля: `/etc/`
- Используемый путь модуля: `/data/FPC/installed/3.1.1/`



В системах, где имена файлов чувствительны к регистру (например, unix и linux), компилятор будет осуществлять:

- поиск исходного имени файла, то есть сохраняет регистр.
- поиск по имени файла все в нижнем регистре.
- поиск по имени файла все в верхнем регистре.



Это необходимо, поскольку Паскаль не зависит от регистра и операторы `uses Unit1` или `uses unit1` должны иметь такой же эффект.

Сначала это будет сделано с расширением *.ppu* (скомпилированный модуль), *.pp*, а затем с расширением *.pas*.

Например, предположим, что файлу *foo.pp* требуется панель инструментов. Тогда команда
```bash
fpc -Fu.. -Fuunits foo.pp
```
скажет компилятору искать панель модулей в следующих местах:

1. В текущем каталоге.
2. В каталоге, где находится бинарный файл компилятора (не в Linux).
3. В родительском каталоге текущего каталога.
4. В подкаталоге `units` текущего каталога
5. В каталоге стандартного модуля.



Кроме того, поиск модулей, имена которых длиннее 8 символов, сначала осуществляется по всей длине имени. Если модуль с таким именем не найден, имя будет усечено до 8 символов, и компилятор снова будет искать в тех же каталогах, но с усеченным именем.

Если компилятор найдет модуль, в котором он нуждается, он будет искать исходный файл этого модуля в том же каталоге, где он нашел модуль. Если он находит исходник модуля, он сравнивает время изменения файла. Если файл-исходник был изменен позже, чем файл модуля, компилятор попытается перекомпилировать модуль посредством этого исходного файла.

Если компилятор не находит скомпилированную версию модуля или когда указана опция -B, то компилятор будет искать исходный файл модуля таким же образом и пытаться перекомпилировать его.

Рекомендуется установить путь поиска модуля в файле конфигурации *fpc.cfg*. Если вы делаете это, вам не нужно указывать путь поиска модуля в командной строке каждый раз, когда вы хотите что-то скомпилировать.



#### 3.1.3 Включаемые файлы.



Если вы включите файл в свой источник с директивой `{$I filename}`, компилятор будет искать его в следующих местах:

1. Он будет смотреть по пути, указанному в имени включаемого файла.
2. Он будет смотреть в каталоге, где находится текущий исходный файл.
3. он будет смотреть во всех каталогах, указанных в пути поиска включаемого файла.


Вы можете добавлять файлы в путь поиска включаемых файлов с помощью опций **-I** (см. раздел [5.1.3](####5.1.3-Опции,-касающиеся-файлов-и-каталогов)) или **-Fi** (см. раздел [5.1.3](####5.1.3-Опции,-касающиеся-файлов-и-каталогов)).

В качестве примера рассмотрим следующую инструкцию include в файле `units/foo.pp`:
```pascal
{$i ../bar.inc}
```
Тогда следующая команда:
```bash
fpc -Iincfiles units/foo.pp
```
заставит компилятор искать в следующих каталогах `bar.inc`:

- Родительский каталог текущего каталога.
- Подкаталог `units` текущего каталога.
- Подкаталог `incfiles` текущего каталога.



#### 3.1.4 Объектные файлы.

Когда вы ссылаетесь на объектные файлы (используя директиву `{$L file.o}`, компилятор будет искать этот файл так же, как он ищет включаемые файлы:

1. Он будет смотреть по пути, указанному в имени файла объекта.
2. Он будет смотреть в каталоге, где находится текущий исходный файл.
3. Он будет смотреть во всех каталогах, указанных в пути поиска объектного файла.

Вы можете добавлять файлы в путь поиска объектных файлов с помощью опции **-Fo** (см. раздел [5.1.3](####5.1.3-Опции,-касающиеся-файлов-и-каталогов)).



#### 3.1.5 Файл конфигурации.

Не все параметры должны быть указаны в командной строке компилятора. Компилятор может использовать файл конфигурации, который может содержать те же параметры, что и в командной строке. В каждой строке файла конфигурации может быть только один параметр командной строки.

Если вы не укажете опцию **-n** (см. раздел [5.1.1](####5.1.1-Общие-параметры)), компилятор будет искать файл конфигурации *fpc.cfg* в следующих местах:

- под Unix (например, Linux)
  1. текущий каталог
  2. ваш домашний каталог, он ищет *.fpc.cfg*
  3. каталог, указанный в переменной окружения **PPC_CONFIG_PATH**
  4. в каталоге `/etc` выше каталога компилятора. Например, если компилятор находится в `/usr/local/bin`, он будет выглядеть в `/usr/local/etc`. См. ниже для получения дополнительной информации об этом пункте
  5. Каталог ``/etc`

- под всеми остальными операционными системами:
  1. текущий каталог
  2. если он установлен, каталог указывается в переменной окружения **PPC_CONFIG_PATH**
  3. каталог, в котором находится компилятор



**Примечание:** обратите внимание, что каталог компилятора определяется местоположением фактического двоичного файла компилятора. Это имеет 2 последствия:

1. Установка по умолчанию в Unix помещает это в `/usr/local/lib/fpc` или `/usr/lib/fpc`. Он помещает несколько символических ссылок в `/usr/local/bin` или `/usr/bin`. Эти символические ссылки не учитываются при поиске файла(ов) конфигурации, поэтому места для поиска файла конфигурации: `/usr/local/lib/fpc/etc` или `/usr/lib/fpc/etc`.

2. Команда `fpc` не является действительным двоичным файлом компилятора. Команда `fpc` выбирает фактический двоичный файл компилятора на основе, например, цель процессора. Фактический двоичный файл компилятора называется *ppcXYZ*.

3. Фактический каталог установки может отличаться: `/usr/local/bin` может быть `/usr/bin`, в зависимости от упаковщика.

   

#### 3.1.6 О длинных именах файлов.

Free Pascal может обрабатывать длинные имена файлов на всех платформах, кроме DOS. В Windows он будет использовать поддержку длинных имен файлов, если она доступна (что не всегда имеет место в более старых версиях Windows).

Если поддержка длинных имен файлов отсутствует, он усекает имена модулей до 8 символов.

Не рекомендуется размещать модули в каталогах, которые содержат пробелы в своих именах, поскольку внешний компоновщик GNU не понимает такие имена файлов.



### 3.2 Компиляция программы.

Компилировать программу очень просто. Предполагая, что у вас есть программный исходник в файле *prog.pp*, вы можете скомпилировать его с помощью следующей команды:
```bash
fpc [options] prog.pp
```

Квадратные скобки [] указывают, что то, что находится между ними, является необязательным.

Если ваш программный файл имеет расширение *.pp* или *.pas*, вы можете опустить это в командной строке, например, в предыдущем примере вы могли набрать:
```bash
fpc [options] prog
```

Если все прошло хорошо, компилятор выдаст исполняемый файл. Вы можете выполнить это прямо сейчас; Вам не нужно больше ничего делать.

Вы заметите, что в вашем каталоге есть еще один файл с расширением *.o*. Он содержит объектный файл для вашей программы. Если вы скомпилировали программу, вы можете удалить объектный файл (*.o*), но не удаляйте его, если вы скомпилировали модуль. Это связано с тем, что объектный файл модуля содержит код модуля и будет связан с любой программой, которая его использует.



### 3.3 Компиляция модуля.

Компиляция модуля принципиально не отличается от компиляции программы. Разница главным образом в том, что в этом случае линкер не вызывается.

Чтобы скомпилировать модуль в файле *foo.pp*, просто введите:

```bash
fpc foo
```

Вспомните замечание о расширениях файлов в предыдущем разделе.

Когда все пройдет хорошо, у вас останется 2 (два) файла:

1. *foo.ppu* - это файл, описывающий модуль, который вы только что скомпилировали.
2. *foo.o* - этот файл содержит актуальный код модуля. Этот файл в конечном итоге окажется в исполняемых файлах.

Оба файла необходимы, если вы планируете использовать модуль для некоторых программ. Так что не удаляйте их. Если вы хотите распространять модуль, вы должны предоставить как *.ppu*, так и *.o* файлы. Один бесполезен без другого.



### 3.4 Модули, библиотеки и умные ссылки.

Компилятор Free Pascal поддерживает умные ссылки и создание библиотек. Однако поведение по умолчанию состоит в том, чтобы скомпилировать каждый модуль в один большой объектный файл, который будет целиком связан с вашей программой. Совместно используемые библиотеки могут создаваться на большинстве платформ, хотя текущий уровень поддержки FPC может отличаться (например, они не поддерживаются для целей GO32v2 и OS2).

Также можно взять существующие модули и собрать их в одну статическую или общую библиотеку (с помощью инструмента **ppumove**, раздел [8.7](###8.7-Программа-ppumove)).



### 3.5 Уменьшение размера вашей программы.

Когда вы создали свою программу, можно уменьшить размер получаемого исполняемого файла. Это возможно, потому что компилятор оставляет в программе много информации, которая, строго говоря, не требуется для выполнения программы.

Избыток информации можно удалить с помощью небольшой программы, которая называется **strip**. Использовать ее просто. Просто введите
```bash
strip prog
```
В командной строке и программа **strip** удалит всю ненужную информацию из вашей программы. Это может привести к уменьшению ее размера до 30%.

Вы можете использовать ключ **-Xs**, чтобы позволить компилятору делать это автоматически во время компиляции программы. (Переключатель не действует при компиляции модулей.)

Другой метод уменьшения размера программы - использование умных ссылок. Обычно модули (включая системный модуль) связаны в целое. Однако возможно скомпилировать модули так, чтобы они могли быть умно связаны. Это означает, что в вашей программе связаны только те функции и процедуры, которые используются фактически, исключая ненужный код. Компилятор включит smartlinking(“умное связывание”) с ключом **-XX** (см. раздел [5.1.4](####5.1.4-Опции,-контролирующие-вид-вывода)). Эта техника полностью описана в  [Programmer’s Guide](https://www.freepascal.org/docs-html/current/prog/prog.html).



# Глава 4

## Проблемы с компиляцией.

### 4.1 Общие проблемы.

**IO-error -2 at ...**: под Linux вы можете получить это сообщение при запуске компилятора. Обычно это означает, что компилятор не находит файл с описанием ошибок. Вы можете исправить эту ошибку с помощью опции **-Fr** (см. раздел [5.1.3](###5.1.3-Опции,-касающиеся-файлов-и-каталогов)) в linux.

**Error: File not found: xxx** или **Error: couldn’t compile unit xxx**: обычно это происходит, когда путь к модулю указан неправильно. Помните, что компилятор ищет модули только в текущем каталоге и в каталоге, где находится сам компилятор. Если вы хотите, чтобы он также поискал модуль где-то еще, вы должны явно указать это, используя опцию **-Fu** (см. раздел [5.1.3](###5.1.3-Опции,-касающиеся-файлов-и-каталогов)). Или вы должны настроить файл конфигурации.



### 4.2 Проблемы, с которыми вы можете столкнуться в DOS.

- **No space in environment**

  Подобное сообщение об ошибке может появиться, если вы вызовете **SET_PP.BAT** в *AUTOEXEC.BAT*.
  Чтобы решить эту проблему, вы должны расширить память вашей среды. Для этого найдите строку в *CONFIG.SYS*, например 
  ```bash
  SHELL=C:\DOS\COMMAND.COM
  ```
  и измените его на следующее:
  ```bash
  SHELL=C:\DOS\COMMAND.COM /E:1024
  ```
  Возможно, вам просто нужно будет указать более высокое значение, если этот параметр уже установлен.

- **Coprocessor missing**
  Если компилятор пишет сообщение об отсутствии сопроцессора, установите эмуляцию сопроцессора.

- **Not enough DPMI memory**
  Если вы хотите использовать компилятор с DPMI, у вас должно быть не менее 7-8 МБ свободной памяти DPMI, но 16 МБ - более реалистичный объем.



# Глава 5

## Конфигурация компилятора.

Вывод компилятора можно контролировать многими способами. Это может быть сделано по существу двумя различными способами:

- Использование параметров командной строки.
- Используя файл конфигурации: *fpc.cfg*.

Компилятор сначала читает файл конфигурации. Только тогда проверяются параметры командной строки. Это создает возможность установить некоторые базовые параметры в файле конфигурации, и в то же время вы все равно можете установить некоторые конкретные параметры при компиляции какого-либо модуля или программы. Сначала мы перечисляем параметры командной строки, а затем объясняем, как указать параметры командной строки в файле конфигурации. Читая это, имейте в виду, что параметры чувствительны к регистру.



### 5.1 Использование параметров командной строки.

Доступные для текущей версии компилятора опции перечислены по категориям. Также см. [Приложение A](#Приложение-A), где приведен список, сгенерированный текущим компилятором.



#### 5.1.1 Общие параметры.

- `-h` Распечатать список всех опций и выйти.
- `-?` То же, что `-h`, ожидание после каждого экрана ввода клавиши ввода.
- `-i` Печать авторских прав и другой информации. Вы можете указать квалификатор как `-i`**xxx**, где **xxx** может быть одним из следующих:
    - `D`: возвращает дату компилятора.
    - `V`: возвращает краткую версию компилятора.
    - `W`: возвращает полную версию компилятора.
    - `SO`: возвращает ОС компилятора.
    - `SP`: возвращает процессор компилятора.
    - `TO`: возвращает целевую ОС.
    - `TP`: возвращает целевой процессор.
    - `a`: возвращает список поддерживаемых целей ABI
    - `c`: возвращает список поддерживаемых наборов команд процессора
    - `f`: возвращает список поддерживаемых наборов команд FPU
    - `i`: возвращает список поддерживаемых режимов встроенного ассемблера
    - `o`: возвращает список поддерживаемых оптимизаций
    - `r`: возвращает список распознанных функций компилятора и RTL
    - `t`: возвращает список поддерживаемых целей
    - `u`: возвращает список поддерживаемых типов микроконтроллеров.
    - `w`: возвращает список поддерживаемых оптимизаций всей программы
- `-l` Распечатать логотип Free Pascal и номер версии.
- `-n` Игнорировать файл конфигурации по умолчанию. Вы по-прежнему можете передать файл конфигурации в качестве параметра командной строки с опцией `@`.
- `-V`**NNN** установить номер версии в **NNN** (добавляет **-NNN** к двоичному имени)



#### 5.1.2 Варианты получения обратной связи.

- `-v`**xxx** Вывод дополнительной информации. **ххх** является комбинацией следующего:
    - `e`: Показать ошибки. Эта опция включена по умолчанию.
    - `i`: Показать некоторую общую информацию.
    - `w`: Выдавать предупреждения.
    - `n`: Выдавать примечания.
    - `h`: Выдавать подсказки.
    - `i`: Выдавать информационные сообщения.
    - `l`: Сообщать количество обработанных строк (каждые 100 строк).
    - `u`: Показать информацию о загружаемых модулях.
    - `t`: Показать имена открываемых файлов.
    - `p`: Писать дерево парсинга (*tree.log*)
    - `q`: Показывать номера сообщений.
    - `c`: Уведомлять о каждой условной обработке.
    - `m`**xxx**: **xxx** - список номеров сообщений, разделенных запятыми, которые не должны отображаться. Эта опция может быть указана несколько раз.
    - `d`: Показать дополнительную информацию об отладке.
    - `0`: (цифра ноль) нет сообщений. Это полезно для переопределения настройки по умолчанию в файле конфигурации.
    - `b`: Показать все объявления процедур в случае ошибки overload(перегруженной) функции.
    - `x`: Показать информацию об исполняемом файле (только для платформы Win32).
    - `r`: Ошибки формата в режиме совместимости RHIDE/GCC.
    - `a`: Показать всю возможную информацию (это то же самое, что указать все параметры).
    - `b`: Заставляет компилятор писать имена файлов, используя полный путь.
    - `v`: Записывать подробную отладочную информацию в файл *fpcdebug.txt*.
    - `s`: Записывать метки времени. В основном для разработчиков компиляторов.
    - `p` Записывать дерево парсинга в файл *tree.log* (предназначено для разработчиков компиляторов.)
    - `z` Записывать сообщения компилятора в стандартную ошибку вместо стандартного вывода.

Разница между фатальной ошибкой/некритичной ошибкой/подсказкой/предупреждением/примечанием заключается в их серьезности:
- **Fatal**(неустранимая ошибка) - компилятор обнаружил ошибку и больше не может продолжать компиляцию. Он остановится сразу. 
- **Error**(некритичная ошибка) - компилятор обнаружил ошибку, но может продолжить компиляцию (самое большее до конца текущего модуля).
- **Warning**(предупреждение) - если есть предупреждение, это означает, что, возможно, есть ошибка, то есть что-то может быть не так в вашем коде.
- **Hint**(подсказка) - выдается, если компилятор считает, что код может быть лучше, но нет никаких подозрений на ошибку.
- **Note**(примечание) - это некоторая заслуживающая внимания информация, но опять же нет ошибок.

Разница между подсказками и примечаниями не очень очевидна. И то, и другое можно игнорировать без особого риска, но всегда следует проверять предупреждения.


#### 5.1.3 Опции, касающиеся файлов и каталогов.

- `-e`**XXX** Указывает **XXX** в качестве каталога, содержащего исполняемые файлы для программ **as** (ассемблер) и **ld** (компоновщик).
- `-Fa`**XYZ** загружает блоки **XYZ** после системного блока, но до загрузки любого другого блока. **XYZ** - это список имен модулей, разделенных запятыми. Это может использоваться только для программ и имеет тот же эффект, как если бы **XYZ** был вставлен в качестве первого элемента в предложении программы.
- `-Fc`**XXX** Установите входную кодовую страницу на **XXX**. Экспериментальный режим. 
- `-FC`**xxx** Установить двоичное имя компилятора RC (компилятор ресурсов) на **xxx**.
- `-Fd` Отключает кеш внутреннего каталога компилятора. По умолчанию компилятор кэширует имена всех файлов в каталоге, как только он ищет один файл в указанном каталоге. Это гарантирует, что в отладочной информации используется правильный регистр всех имен файлов. Это также позволяет создавать скомпилированные файлы с правильным регистром при компиляции в файловых системах с сохранением регистра в ОС, которые также поддерживают файловые системы с учетом регистра. Наконец, это также может повысить производительность. Однако эта функция может вызвать серьезные замедления в сетевых файловых системах, особенно при компиляции тривиальных программ в каталогах, содержащих много файлов, и такие замедления можно устранить, отключив кэш с помощью этого переключателя.
- `-FD` То же, что и `-e`.
- `-Fe`**xxx** Записывать ошибки и т.д. в файл с именем **xxx**.
- `-FE`**xxx** Записать исполняемый файл и модули в каталог **xxx** вместо текущего каталога. Если этот параметр содержит компонент пути и сопровождается параметром `-o` (см. раздел [5.1.4](####5.1.4-Опции,-контролирующие-вид-вывода)), то путь `-o` переопределит параметр пути `-FE`.
- `-Ff`**xxx* Добавить **ххх** к пути фреймворка (только для Darwin).
- `-Fg` ?
- `-Fi`**xxx** Добавить **xxx** к пути поиска включаемого файла.
- `-Fl`**xxx** Добавить **ххх** в путь поиска библиотеки (это также передается компоновщику).
- `-FL`**xxx** (только linux) Использовать **xxx** в качестве динамического компоновщика. По умолчанию используется `/lib/ld-linux.so.2` или `/lib/ld-linux.so.1`, в зависимости от того, какой из них будет найден первым.
- `-Fm`**xxx** Загрузить таблицу преобразования юникода из файла *x.txt* в каталоге, где находится компилятор. Используется только когда действует `-Fc`.
- `-FM`**xxx** Установить каталог, где искать двоичные файлы Unicode, в **xxx**.
- `-Fo`**xxx** Добавить **ххх** в путь поиска объектного файла. Этот путь используется при поиске файлов, которые должны быть связаны с ним.
- `-Fr`**xxx** Укажите **xxx** в качестве файла, который содержит сообщения компилятора. Это заменит встроенные по умолчанию сообщения компилятора на английском языке.
- `-FR`**xxx** установить для линкера ресурса (*.res*) значение **xxx**.
- `-Fu`**xxx** Добавить **ххх** в путь поиска модуля. Объекты сначала ищутся в текущем каталоге. Если они там не найдены, то компилятор ищет их по пути к модулю. Вы всегда должны указывать путь к системному модулю. Путь **xxx** может содержать один подстановочный знак (*), который будет расширен до всех возможных имен каталогов, найденных в этом месте. Обратите внимание, что само местоположение не входит в список. См. раздел [3.1.2](####3.1.2.-Модули-файлов) для получения дополнительной информации об этой опции.
- `-FU`**xxx** Записать модули в каталог *ххх* вместо текущего каталога. Он переопределяет опцию `-FE`.
- `-I`**xxx** Добавить **xxx** к пути поиска включаемого файла. Эта опция имеет тот же эффект, что и `-Fi`.
- `-FW`**xxx** хранить сгенерированную информацию по оптимизации всей программы в файле **xxx**.
- `-Fw`**xxx** Считать всю информацию по оптимизации программы (сохраненную с помощью `-FW`**xxx**) из файла **xxx**.



#### 5.1.4 Опции, контролирующие вид вывода.

Для получения дополнительной информации об этих параметрах см. [Programmer’s Guide](https://www.freepascal.org/docs-html/current/prog/prog.html).

- `-a` Не удалять файлы ассемблера (неприменимо при использовании внутреннего ассемблера). Это также относится к (возможно) сгенерированному пакетному сценарию.

- `-al` Включить строки исходного кода в файл ассемблера в качестве комментариев.

- `-an` Запись информации об узле в файл ассемблера (узлы - это способ, которым компилятор представляет операторы или их части внутри). Это в первую очередь предназначено для отладки кода, сгенерированного компилятором.

- `-ap` Использовать каналы вместо создания временных файлов ассемблера. Это может ускорить компилятор в OS/2 и Linux. Только с ассемблерами (такими как **GNU**, если используется внутренний ассемблер).

- `-ar` Вывести информацию о расположении и выпуске регистра в файле ассемблера. Это в первую очередь предназначено для отладки кода, сгенерированного компилятором.
- `-at` Вывести информацию о временных выделениях и освобождениях памяти в файле ассемблера.

- `-A`**xxx** указать, какой тип ассемблера должен быть сгенерирован. Здесь **ххх** является одним из следующих параметров:
    - `default` - используется встроенный по умолчанию.
    - `as` - сборка с использованием GNU **as**.
    - `gas` - сборка с использованием GNU **gas**.
    - `gas-darwin` - сборка с использованием GNU **gas** для darwin Mach-O64.
    - `nasmcoff` - Coff (Go32v2) файл с использованием **Nasm**.
    - `nasmelf` - Elf32 (linux) файл с использованием **Nasm**.
    - `nasmwin32` - Windows 32-битный файл с использованием **Nasm**.
    - `nasmwin64` - Windows 64-битный файл с использованием **Nasm**.
    - `nasmwdosx` - Windows 32-bit/DOSX файл с использованием **Nasm**.
    - `nasmdarwin` Объектный файл с использованием Nasm.darwin Mach-O64 с использованием GNU **GAS**
    - `macho` - Mach-O (Darwin, Intel 32 бит) с использованием внутренней программы записи.
    - `masm` - объектный файл с использованием Masm (Microsoft).
    - `tasm` - объектный файл с использованием Tasm (Borland).
    - `elf` - Elf32 (linux) с использованием внутреннеей программы записи.
    - `coff` - объектный файл Coff (Go32v2), использующий внутреннюю программу записи двоичных объектов.
    - `pecoff` - объектный файл PECoff (Win32) с использованием внутренней программы записи двоичных объектов.
    - `wasm` - объектный файл с использованием wasm (Watcom).
    - `yasm` - объектный файл, использующий **yasm** (экспериментально).

- `-B` Перекомпилировать все использованные модули, даже если исходники модулей не изменились со времени последней компиляции.

- `-b` Создать информацию о браузере. Эта информация может использоваться интегрированной средой разработки (IDE) для предоставления информации о классах, объектах, процедурах, типах и переменных в модуле.

- `-bl` То же, что и `-b`, но также генерирует информацию о локальных переменных, типах и процедурах.

- `-C3` Включить (или выключить) проверку ошибок IEEE для констант.

- `-Ca`**xxx** Задать ABI (двоичный интерфейс приложения) в **xxx**. Опция `-i` задает возможные значения для **ххх**.

- `-Cb` Создать код с прямым порядком байтов (big-endian).

- `-Cc` Установить соглашение о вызовах по умолчанию, используемое компилятором.

- `-CD` Создать динамическую библиотеку. Это используется для преобразования модулей в динамически подключаемые библиотеки в Linux.
Эмулировать операции с плавающей точкой.

- `-Ce` Эмулировать операции с плавающей точкой.

- `-Cf`**xxx** Задать используемый процессор с плавающей точкой в **xxx**. `fpc -i` перечисляет все возможные значения.

- `-CF`**NN** Установить минимальную точность с плавающей точкой равной **NN**. Возможные значения 32 и 64.

- `-Cg` Включить генерацию кода PIC. Это должно быть необходимо только при создании библиотек в Linux или других никсах.

- `-Ch`**xxx** резервирует **ххх** байтов в куче. **ххх** должен быть в интервале между 1024 и 67107840.

- `-Ci` Создать код проверки ввода/вывода. Если какой-либо код ввода/вывода вашей программы вернет статус ошибки, программа закроется с ошибкой во время выполнения. Какая ошибка генерируется, зависит от ошибки ввода/вывода.

- `-Cn` Пропустить этап связывания.

- `-CN` Генерировать проверки с нулевым указателем (только для AIX).

- `-Co` Создать целочисленный код проверки переполнения. В случае целочисленных ошибок ваша программа сгенерирует ошибку времени выполнения.

- `-CO` Проверка на возможное переполнение целочисленных операций.

- `-Cp`**XXX** Задать тип процессора в **XXX**.

- `-CP`**X**=**N** Задать упаковку для **X** в **N**. **X** может иметь значение **PACKSET**, **PACKENUM** или **PACKRECORDS*, а **N** может иметь значение 1,2,4,8 или быть одним из ключевых слов **DEFAULT(0)** или **NORMAL**. **PACKRECORDS** также поддерживает значения 16 и 32. (см. [Programmer’s Guide](https://www.freepascal.org/docs-html/current/prog/prog.html) для получения дополнительной информации).

- `-Cr` Генерировать код проверки диапазона. Если ваша программа обращается к элементу массива с недопустимым индексом или увеличивает перечисляемый тип за пределы своей области, будет сгенерирована ошибка времени выполнения.

- `-CR` Генерировать проверки при вызове методов верификации  правильности таблицы виртуальных методов для этого объекта.

- `-Cs`**xxx** Задать размер стека в **xxx**.

- `-Ct` Создать код проверки стека. Если ваша программа выполняет ошибочную работу стека, будет сгенерирована ошибка времени выполнения.

- `-CT`**NNN** Конкретные параметры генерации кода:
  
- `cld` Выдать инструкцию CLD перед использованием строковых инструкций x86
  
- `-CX` Создать при записи Smartlink-модуль. Smartlink-модуль будет связывать только те части кода, которые действительно нужны программе. Весь не используемый код не учитывается. Это может привести к существенно меньшим размерам двоичных файлов.

- `-d`**xxx** Задать имя символа **xxx**. Это может быть использовано для условной компиляции частей вашего кода.

- `-D` Создать файл DEF (для OS/2).

- `-Dd` Задать описание исполняемого файла/библиотеки (Windows).

- `-Dv` Задать версию исполняемого файла/библиотеки (Windows).

- `-Dw` PM-приложение (для OS/2)

- `-E` аналогично `-Cn`.

- `-fPIC` аналогично `-Cg`.

- `-g` Генерировать отладочную информацию для отладки с помощью файла *gdb*.

- `-gc` Генерировать проверку для указателей. Это должно использоваться с параметром командной строки `-gh`. Когда этот параметр включен, он будет проверять, что все обращения к указателю находятся в куче.

- `-gg` аналогично `-g`.

- `-gh` Использовать модуль heaptrc (см. [Unit Reference](https://www.freepascal.org/docs-html/current/rtl/index.html)). (Создает отчет об использовании кучи после выхода из программы)

- `-gl` Использовать модуль lineinfo (см. [Unit Reference](https://www.freepascal.org/docs-html/current/rtl/index.html)). (Создает информацию об имени файла/номере строки, если программа завершает работу из-за ошибки.)

- `-go`**XXX** Задать параметры отладочной информации. Один из вариантов - `dwarfsets`: он включает отладочную информацию для формата отладки **dwarf** (это не работает с версиями *gdb* до 6.5). *Stabsabsinclude* указывает компилятору хранить абсолютные/полные пути include-файлов в формате отладки stabs. *Dwarfmethodclassprefix* указывает компилятору префиксировать имена методов в DWARF в виде `class name.item[-gp]`, сохраняя регистр в именах символов формата отладки stabs. По умолчанию - все имена сохраняются в верхнем регистре.

- `-gs` Записать отладочную информацию в формате отладки stabs.

- `-gt` Очищать локальные переменные от мусора. Это записывает случайное значение в локальные переменные при запуске процедуры. Это может быть использовано для обнаружения неинициализированных переменных. t может быть указан несколько раз

- `-gv` Извлечь информацию для valgrind.

- `-gw` Извлечь информацию об отладке dwarf (версия 2).

- `-gw2` Извлечь информацию об отладке dwarf (версия 2).

- `-gw3` Извлечь информацию об отладке dwarf (версия 3).

- `-gw4` Извлечь информацию об отладке dwarf (версия 4, экспериментальная).

- `-k`**xxx** Передать **ххх** компоновщику.

- `-N`**xxx** Выполнить оптимизацию узлов дерева. Здесь **ххх** является одним из
  
    - `u` развернуть петли
    
- `-O`**xxx** Оптимизировать вывод компилятора; **xxx** может иметь одно из следующих значений:

    **aPARAM=VALUE**
Указывает выравнивание структур и кода. **PARAM** определяет, что должно быть выровнено; **VALUE** определяет границу выравнивания. См.  [Programmer’s Guide](https://www.freepascal.org/docs-html/current/prog/prog.html) для описания возможных значений.

    - `1` Уровень оптимизации 1 (быстрая и удобная для отладчика оптимизация).
    - `2` Уровень оптимизации 2 (-O1 плюс быстрая оптимизация).
    - `3` Уровень оптимизации 3 (-O2 плюс более медленные оптимизации).
    - `4` Уровень оптимизации 4 (-O3 плюс оптимизации, которые могут иметь побочные эффекты).
    - `o`**NNN** Указывает индивидуальные параметры оптимизации: **NNN** может быть одним из
        - `REGVAR` Использовать переменные регистра
        - `UNCERTAIN` Неопределенная оптимизация (используйте с осторожностью)
        - `STACKFRAME` Пропустить кадры стека
        - `PEEPHOLE` Оптимизация глазка
        - `ASMCSE` Устранение общего подвыражения на уровне ассемблера (только для i386, устарело)
        - `LOOPUNROLL` Развернуть (маленькие) петли
        - `TAILREC` Изменить концевую рекурсию на нерекурсивный цикл
        - `CSE` Устранение общего подвыражения
        - `DFA` Включить анализ потока данных
        - `USEEBP` Использовать регистр EBP/RBP для хранения переменных (только для x86)
        - `ORDERFIELDS` Переупорядочить поля экземпляра класса, если это приводит к лучшему выравниванию
        - `FASTMATH` Быстрые математические операции (могут снизить точность с плавающей точкой)
        - `REMOVEEMPTYPROCS` Удалить вызовы пустых процедур.
        - `CONSTPROP` Дублирование констант (экспериментальное, требует `-Oodfa`)

    - `p`**xxx** Выбрать процессор **xxx** для оптимизации. `fpc -i` выводит список всех доступных наборов инструкций процессора.
    - `W`**xxx** Генерировать информацию по оптимизации всей программы для функции **xxx**. `fpc -i` сгенерирует список возможных значений.
    - `w`**xxx** Выполнить информацию по оптимизации всей программы для функции **xxx**. `fpc -i` сгенерирует список возможных значений.
    - `s` Оптимизация по размеру, а не по скорости. Точный эффект некоторых из этих оптимизаций можно найти в [Programmer’s Guide](https://www.freepascal.org/docs-html/current/prog/prog.html).
    
- `-o`**xxx** Использовать **xxx** в качестве имени выходного файла (исполняемого файла). Для использования только с программами. Выходное имя файла может содержать путь, и если он есть, оно переопределит любую предыдущую настройку `-FE`. Если выходное имя файла не содержит пути, параметр `-FE` проявляется.
- `-pg` Создать код профиля для `gprof`. Это определит символ **FPC_PROFILE**, который можно использовать в условных определениях.
- `-PB` Показать двоичный файл компилятора целевого CPU по умолчанию
- `-PP` Показывать целевой процессор по умолчанию
- `-P`**xxx** Установить целевой процессор (arm, avr, i386, jvm, m68k, mips, mipsel, powerpc, powerpc64, sparc, x86_64)
- `-s` Не вызывать ассемблер и компоновщик. Вместо этого компилятор пишет сценарий *PPAS.BAT* в DOS или *ppas.sh* в Linux, который затем может быть выполнен для создания исполняемого файла. Это может быть использовано для ускорения процесса компиляции или для отладки вывода компилятора. Эта опция может принимать дополнительный параметр, в основном используемый для кросс-компиляции. Может иметь одно из следующих значений:
   - `h` Создавать скрипт для связывания на хосте. Сгенерированный скрипт может быть запущен на платформе компиляции (хост-платформа).
   - `t` Создавать скрипт для связи на целевой платформе. Сгенерированный скрипт может быть запущен на целевой платформе (где двоичный файл предназначен для запуска).
   - `r` Пропустить этап выделения регистров (оптимизации будут отключены).
- `-T`**xxx** Указывает целевую операционную систему. **xxx** может быть одним из следующих:

    - **darwin**: Darwin Mac OS/X.
    - **emx**: OS/2 через EMX (и DOS через EMX extender).
    - **FreeBSD**: FreeBSD.
    - **go32v2**: DOS и версия 2  расширения DJ DELORIE.
    - **iphonesim**: симулятор iPhone.
    - **linux**: Linux.
    - **netbsd**: NetBSD.
    - **netware**: модуль Novell Netware (clib).
    - **netwlibc**: модуль Novell Netware (libc).
    - **openbsd**: OpenBSD.
    - **os2**: OS/2 (2.x) с использованием расширения EMX.
    - **sunos**: SunOS/Solaris.
    - **watcom**: Watcom-совместимое расширение DOS
    - **wdosx**: расширение WDOSX.
    - **win32**: 32-битная Windows.
    - **win64**: 64-битная Windows.
    - **wince**: Windows для карманных компьютеров (процессор ARM).

Доступный список целей зависит от фактического двоичного файла компилятора. Используйте `fpc -i`, чтобы получить список целей, поддерживаемых двоичным файлом компилятора.
- `-u`**xxx** Отменить определение символа **xxx**. Это противоположно опции `-d`.
- `-Ur` Генерировать релизные файлы модуля. Эти файлы не будут перекомпилированы, даже когда исходники доступны. Это полезно при создании дистрибутивов. Это также переопределяет опцию `-B` для модулей  режима release.
- `-W` Установить некоторые атрибуты Windows или os/2 сгенерированного двоичного файла. Он(и) могут быть одним из ниже перечисленных:
   - `A` Указать собственного тип приложения (Windows)
   - `b` Создать пакет вместо библиотеки ((Darwin)
   - `B` Создать локализуемое изображение (Windows)
   - `B`**hhh** Установить предпочтительный базовый адрес в **hhh** (шестнадцатеричный адрес)
   - `C` Сгенерировать консольное(+) или графическое приложение (-) приложение.
   - `D` Принудительно использовать файл Def для экспорта.
   - `e` Использовать внешние ресурсы (Darwin)
   - `F` Создать FS-приложение (+) или консольное приложение (-).
   - `G` Создать приложение с графическим интерфейсом (+) или консольное приложение (-).
   - `i` Использовать внутренние (FPC) ресурсы (Darwin)
   - `I` Включить/Выключить использование разделов импорта (Windows)
   - `M`**nnn** Минимальная версия развертывания Mac OS X: **nnn** равно 10.4, 10.5.1, ... (Darwin)
   - `N` Не создавать раздел перемещения.
   - `P`**XXX** Минимальная версия **XXX** iOS (iphonesim) для развертывания: 8.0, 8.0.2 и т.д.
   - `R` Создать раздел перемещения.
   - `T` Создать TOOL-приложение (+) или консольное приложение (-).
   - `X` Включить использование исполняемого стека (Linux)

- `-X`**x** Указать исполняемые параметры. Это сообщает компилятору, какой тип исполняемого файла должен быть сгенерирован. Параметр **x** может быть одним из следующих:

    - `c`:(только linux) Связь с библиотекой C. Вы должны использовать это только тогда, когда вы начинаете портировать Free Pascal в другую операционную систему.
    - `d`: Не использовать стандартный путь к библиотеке. Это необходимо для кросс-компиляции, чтобы избежать связи с библиотеками платформы хоста.
    - `D`: Связь с динамическими библиотеками (определяет символ **FPC_LINK_DYNAMIC**)
    - `e`: Использовать внешний (GNU) компоновщик.
    - `f`: Подстановка имени библиотеки **pthread** для линковки (BSD).
    - `g`: Создать отладочную информацию в отдельном файле и добавить раздел отладочных ссылок в исполняемый файл.
    - `i`: Использовать внутренний линкер.
    - `LA`: Определить подстановку имен библиотек для стадии связывания.
    - `LO`: Определить порядок связывания библиотек.
    - `LD`: Исключить порядок по умолчанию для стандартных библиотек.
    - `M`**XXX**: установить имя подпрограммы ввода программы. По умолчанию используется значение «main».
    - `m`: Создать map-файл компоновщика.
    - `n`: Использовать собственный компоновщик целевой системы вместо GNU **ld** (Solaris, AIX)
    - `p`**XXX**: Искать двоичный файл компилятора сначала в каталоге **XXX**(только для команд fpc).
    - `P`**XXX**: Добавить имена binutils к **XXX** для кросс-компиляции.
    - `r`**XXX**: Задать путь к библиотеке в **XXX**.
    - `R`**xxx**: Добавить **xxx** ко всем путям поиска компоновщика (используется для кросс-компиляции).
    - `s`: Убрать символы из исполняемого файла.
    - `S`: Ссылка на статические модули (задается символом **FPC_LINK_STATIC**).
    - `t`: Статическая ссылка (передает параметр `-static` компоновщику).
    - `v`: Создать таблицу для вызовов виртуального входа.
    - `X`: Ссылка на смарт-линкованный модуль (задается символом **FPC_LINK_SMART**).



#### 5.1.5 Опции, касающиеся исходников (языковые опции).

Для получения дополнительной информации об этих параметрах см. [Programmer’s Guide](https://www.freepascal.org/docs-html/current/prog/prog.html).

- `-Mmode` Задает языковой режим в режим, который может быть одним из следующих:
    - `Delphi` Попытка быть совместимым с Delphi. Это более строгий режим, чем `objfpc`, поскольку некоторые расширения Free Pascal отключены.
    - `fpc` Диалект Free Pascal (по умолчанию).
    - `macpas` Попытка быть совместимыми с диалектами Macintosh Pascal.
    - `objfpc` Включает некоторые расширения Delphi. Это отличается от режима Delphi, поскольку некоторые конструкции Free Pascal все еще доступны.
    - `tp` Попытка быть совместимым с TP/BP 7.0. Это означает отсутствие всяческих более поздних фишек вроде перегрузки функций и т.д.
    - `ISO` В этом режиме компилятор соответствует требованиям уровня 0 и уровня 1 стандарта ISO/IEC 7185.

- `-Mfeature` Выбирает языковые особенности функций языка. Начиная с FPC версии 2.3.1, ключ командной строки `-M` может использоваться для выбора отдельных языковых функций. В этом случае функция является одним из следующих ключевых слов:

    - `CLASS` Используются классы объектного паскаля.
    - `OBJPAS` Автоматически включает модуль ObjPas.
    - `RESULT` Включает идентификатор Result для результатов функции.
    - `PCHARTOSTRING` Разрешает автоматическое преобразование нуль-детерминированных строк с нулевым символом в конце,
    - `CVAR` Разрешает использование ключевого слова CVAR.
    - `NESTEDCOMMENTS` Разрешает использование вложенных комментариев.
    - `CLASSICPROCVARS` Используйте классические процедурные переменные.
    - `MACPROCVARS` Используются процедурные переменные в стиле Mac.
    - `REPEATFORWARD` Реализация и предварительная декларация должны полностью совпадать.
    - `POINTERTOPROCVAR` Разрешить тихое преобразование указателей в процедурные переменные.
    - `AUTODEREF` Автоматическая (тихая) разыменование типизированных указателей.
    - `INITFINAL` Разрешить использование секций Initialization и Finalization
    - `ANSISTRINGS` Разрешить использование ansistrings.
    - `OUT` Разрешить использование типа параметра out.
    - `DEFAULTPARAMETERS` Разрешить использование значений параметров по умолчанию.
    - `HINTDIRECTIVE` Поддержка директив подсказок (deprecated, platform и т.д.).
    - `DUPLICATELOCALS` Разрешить аргументы метода с тем же именем, что и свойства в классах.
    - `PROPERTIES` Разрешить использование глобальных свойств.
    - `ALLOWINLINE` Разрешить  inline-процедуры.
    - `EXCEPTIONS` Разрешить использование исключений.
    - `OBJECTIVEC1` Разрешить использование objective C версии 1.
    - `OBJECTIVEC2` Разрешить использование objective C версии 2.
    - `NESTEDPROCVARS` Разрешить присваивать локальные процедуры вложенным процедурным переменным и определять встроенные типы процедурных переменных, которые всегда могут принимать локальные процедуры, в объявлениях параметров.
    - `NONLOCALGOTO` Разрешить оператору GOTO выходить за пределы локальной области видимости (как ISO Pascal).
    - `ADVANCEDRECORDS` Разрешить использование расширенных записей (записей с методами/свойствами)
    - `ISOUNARYMINUS` Обрабатывать унарный минус как в ISO Pascal: тот же уровень приоритета, что и двоичный минус/плюс.
Ключевое слово может сопровождаться знаком плюс или минус, чтобы включить или отключить функцию.

- `-R`**xxx** Указать, какой тип ассемблера вы используете в кодовых блоках ассемблера asm. Здесь ххх является одним из следующих:
    - `att` блоки asm содержат ассемблер в стиле AT&T. Это стиль используется по умолчанию.
    - `intel` блоки asm содержат ассемблер в стиле Intel.
    - `default` использовать ассемблер по умолчанию для указанной цели.
    - `direct` блоки asm должны быть скопированы как есть в ассемблере с заменой только определенных переменных.

- `-S2` Включить расширения Delphi 2 (режим objfpc). Устаревший, используйте вместо этого `-Mobjfpc`.
- `-Sa` Включать операторы `assert` в скомпилированный код. Если вы пропустите эту опцию, операторы assert будут проигнорированы.
- `-Sc` Поддержка операторов в стиле C, т.е. `*=`, `+=`, `/=` и `-=`.
- `-Sd` Попытка Delphi-совместимости. Устаревший, используйте вместо этого `-Mdelphi`.
- `-SeN` Компилятор останавливается после N-й ошибки. Обычно компилятор пытается продолжить компиляцию после ошибки, пока не будет достигнуто 50 ошибок или не будет достигнута фатальная ошибка, а затем он остановится. С этим переключателем компилятор остановится после N-й ошибки (если N опущено, предполагается значение по умолчанию 1). Вместо числа также можно указать один из `n`, `h` или `w`. В этом случае компилятор будет рассматривать заметки, подсказки или предупреждения как ошибки и останавливаться при их обнаружении.

- `-Sf` Включить определенные функции в компиляторе и RTL. Это позволяет лучше контролировать доступные языковые функции, чем переключатель режима. Возможные значения:

    - `HEAP` Разрешить использование кучи памяти.
    - `INITFINAL` Initialization/finalization.
    - `RTTI` Разрешить использование RTTI.
    - `CLASSES` Разрешить использование классов.
    - `EXCEPTIONS` Разрешить использование исключений.
    - `EXITCODE` Разрешить использование кода выхода для приложений.
    - `ANSISTRINGS` Разрешить использование ansistring.
    - `WIDESTRINGS` Разрешить использование widestring.
    - `TEXTIO` Разрешить использование стандартного ввода-вывода текстового файла Pascal.
    - `CONSOLEIO` Разрешить использование стандартного ввода-вывода консоли Pascal (текстовый файл).
    - `FILEIO` Позволяет использовать стандартный ввод/вывод двоичного файла Pascal.
    - `RANDOM` Разрешить использование функции Random().
    - `VARIANTS` Разрешить использование variants.
    - `OBJECTS` Разрешить использование объектов в стиле TP.
    - `DYNARRAYS` Разрешить использование динамических массивов.
    - `THREADING` Разрешить использование потоков.
    - `COMMANDARGS` Разрешить использование аргументов командной строки.
    - `PROCESSES` Разрешить использование процессов.
    - `STACKCHECK` Включить проверку стека.
    - `DYNLIBS` Разрешить использование динамически загружаемых библиотек в системном модуле.
    - `SOFTFPU` Разрешить (включить) использование программных операций с плавающей точкой.
    - `OBJECTIVEC1` Разрешить использование подпрограмм поддержки Objective C.
    - `RESOURCES` Разрешить использование ресурсов.
    - `UNICODESTRING` Разрешить использование строк Unicode.

- `-Sg` Поддержка команды label и goto. По умолчанию они не поддерживаются. Вы также должны указать эту опцию, если вы используете метки в инструкциях ассемблера. (если вы используете сборщик в стиле AT & T)
- `-Sh` Использовать ansistring по умолчанию для строк. Если указана эта опция, компилятор будет интерпретировать ключевое слово string как ANSISTRING. В противном случае это должна быть  SHORTSTRING (стиль TP).
- `-Si` поддержка C ++ в стиле INLINE.
- `-SI`**XXX** Установить стиль интерфейса на **XXX**. Здесь **XXX** является одним из:
- 
    - `COM` COM-совместимые интерфейсы (подсчет ссылок, наследуется от IUnknown).
    - `CORBA` Интерфейсы без подсчета ссылок.

- `-Sk` Загрузить модуль совместимости Kylix (`fpcylix`). 
- `-Sm` Поддержка макросов в стиле C. 
- `-So` попытка совместимости с Borland TP 7.0. Устаревший ключ, используйте вместо этого `-Mtp`. 
- `-Ss` Имя конструкторов должно быть `init`, имя деструкторов должно быть `done`. 
- `-St` Разрешить ключевое слово `static` в объектах. 
- `-Sv` Поддержка векторной обработки (использует расширения вектора процессора, если доступны) 
- `-Sx` Включить ключевые слова exception (как по умолчанию в режиме Delphi/Objfpc). Это помечает все ключевые слова, связанные с исключениями, как ключевые слова(keywords), также как это делается в Turbo Pascal или в режиме FPC. Это можно использовать для проверки кода, который должен быть как можно более независимым от режима. 
- `-Sy` `@pointer` возвращает типизированный указатель, это то же самое, что и опция `$T+`. 
- `-Un` Не проверять имя модуля. Обычно имя модуля совпадает с именем файла. Эта опция позволяет им быть разными.
- `-Us` компилировать системный модуль. Эта опция заставляет компилятор задавать только некоторые очень простые типы.



### 5.2 Использование файла конфигурации.

Использование файла конфигурации *fpc.cfg* является альтернативой параметрам командной строки. Когда файл конфигурации найден, он читается, и строки в нем обрабатываются так, как если бы вы ввели их в качестве параметров в командной строке: указывайте по одному параметру в каждой строке файла конфигурации. Они будут обработаны компилятором перед параметрами, которые вы введете уже в командной строке.

Вы можете указывать комментарии в файле конфигурации с помощью символа `#`. Все символы в строке после # будут игнорироваться.

Алгоритм определения того, какой файл используется в качестве файла конфигурации, описан в разделе [3.1.5](####3.1.5-Файл-конфигурации).

Когда компилятор завершает чтение файла конфигурации, он продолжает обрабатывать параметры командной строки.

Один из параметров командной строки позволяет указать второй файл конфигурации: указание `@foo` в командной строке откроет файл *foo* и прочитает дополнительные параметры оттуда. Когда компилятор завершил чтение этого файла, он продолжит обрабатывать командную строку.



#### 5.2.1 Условная обработка файла конфигурации.

В дополнение к замене подстановки, файл конфигурации допускает тип предварительной обработки. Он понимает следующие директивы, которые вы должны поместить, начиная с первого столбца строки:

- `#CFGDIR`
- `#IFDEF`
- `#IFNDEF`
- `#ELSE`
- `#ENDIF`
- `#DEFINE`
- `#UNDEF`
- `#WRITE`
- `#INCLUDE`
- `#SECTION`

Они работают так же, как их `{$...}`-аналоги в исходном коде Pascal. Все определения по умолчанию, используемые для компиляции исходного кода, также задаются при обработке файла конфигурации. Например, если целевой компилятор представляет собой платформу linux, совместимую с Intel 80x86, то при интерпретации файла конфигурации будут определены как cpu86, так и linux. Для определения возможных значений по умолчанию при компиляции обратитесь к Приложению G [Programmer’s Guide](https://www.freepascal.org/docs-html/current/prog/progap7.html#x333-349000G)

Далее следует описание различных директив.



#### 5.2.2 #CFGDIR.

Синтаксис:
```bash
#CFGDIR /path/to/config/dir
```
Задает каталог, в котором компилятор ищет файлы конфигурации, которые он включает через директиву `#INCLUDE`. Путь может содержать обычные подстановки, которые будут заменены соответствующими значениями. Подставленные значения - это значения в тот момент, когда встречается директива `#CFGDIR`.



#### 5.2.3 #IFDEF.

Синтаксис:
```bash
#IFDEF name
```
Строки, следующие за `#IFDEF`, доступны только для чтения, если ключевое слово `name`, следующее за ним, определено.

Они читаются до тех пор, пока не встретятся ключевые слова `#ELSE` или `#ENDIF`, после чего возобновится нормальная обработка.

Пример :
```bash
#IFDEF VER2_6_0 
-Fu/usr/lib/fpc/2.6.0/linuxunits
#ENDIF
```

В приведенном выше примере */usr/lib/fpc/2.6.0/linuxunits* будет добавлен в PATH, если вы компилируете версию 2.6.0 компилятора.



#### 5.2.4 #IFNDEF.

Синтаксис:
```bash
#IFNDEF name
```
Строки, следующие за `#IFNDEF`, доступны только для чтения, если ключевое слово `name` после него не определено.

Они читаются до тех пор, пока не встретятся ключевые слова `#ELSE` или `#ENDIF`, после чего возобновится нормальная обработка.

Пример:
```bash
#IFNDEF VER2_6_0
-Fu/usr/lib/fpc/2.6.0/linuxunits
#ENDIF
```
В приведенном выше примере `/usr/lib/fpc/2.6.0/linuxunits` будет добавлен в PATH, если вы НЕ компилируете версию 2.6.0 компилятора.



#### 5.2.5 #ELSE.

Синтаксис:
```bash
#ELSE
```
`#ELSE` можно указать после директивы `#IFDEF` или `#IFNDEF` в качестве альтернативы. Строки, следующие за `#ELSE`, доступны только для чтения, если предыдущие `#IFDEF` или `#IFNDEF` не были приняты.

Они пропускаются до тех пор, пока не встретится ключевое слово `#ENDIF`, после чего возобновится нормальная обработка.

Пример :
```bash
#IFDEF VER2_6_2
-Fu/usr/lib/fpc/2.6.2/linuxunits
#ELSE
-Fu/usr/lib/fpc/2.6.0/linuxunits
#ENDIF
```
В приведенном выше примере */usr/lib/fpc/2.6.2/linuxunits* будет добавлен в PATH, только если вы компилируете версию 2.6.2 компилятора, в противном случае в PATH будет добавлен */usr/lib/fpc/2.6.0/linuxunits*.



#### 5.2.6 #ENDIF.

Синтаксис:
```bash
#ENDIF
```
`#ENDIF` отмечает конец блока, который начинается с `#IF(N)DEF`, возможно, с `#ELSE` между ними.



#### 5.2.7 #DEFINE.

Синтаксис:
```bush
#DEFINE name
```
`#DEFINE` определяет новое ключевое слово `name`. Это имеет тот же эффект, что и опция командной строки `-dname`.



#### 5.2.8 #UNDEF.

Синтаксис:
```bash
#UNDEF name
```
`#UNDEF` отменяет определение ключевого слова `name`, если оно существует. Это имеет тот же эффект, что и опция командной строки `-uname`.



#### 5.2.9 #WRITE.

Синтаксис:
```bash
#WRITE Message Text
```
`#WRITE` записывает `Message Text` на экран. Это может быть полезно для отображения предупреждений, если установлены определенные параметры.

Пример:
```bash
#IFDEF DEBUG
#WRITE Setting debugging ON...
-g
#ENDIF
```
Если `DEBUG` определен, то получится строка:
```bash
Setting debugging ON...
```
и затем включит отладочную информацию в компиляторе.



#### 5.2.10 #INCLUDE.

Синтаксис:
```bash
#INCLUDE filename
```
`#INCLUDE` дает указание компилятору прочитать содержимое `filename` прежде, чем продолжить обработку параметров в текущем файле.

Это может быть полезно, если вы хотите иметь конкретный файл конфигурации для проекта (или, под LINUX, в вашем домашнем каталоге), но все же хотите иметь глобальные параметры, которые задаются в глобальном файле конфигурации.

Пример:
```bash
#IFDEF LINUX
  #INCLUDE /etc/fpc.cfg
#ELSE
  #IFDEF GO32V2
  #INCLUDE c:\pp\bin\fpc.cfg  
  #ENDIF
#ENDIF
```
Это включит */etc/fpc.cfg*, если вы работаете на машине с LINUX или включит *c:\pp\bin\fpc.cfg* на машине с DOS.



#### 5.2.11 #SECTION.

Синтаксис:
```bash
#SECTION name
```
Директива `#SECTION` действует как и директива `#IFDEF`, только для нее не требуется директива `#ENDIF`. Специальное имя `COMMON` всегда существует, то есть строки, следующие  после `#SECTION COMMON`, читаются всегда.



### 5.3 Подстановка переменных в путях.

Чтобы избежать необходимости слишком часто редактировать файлы конфигурации, компилятор позволяет вставлять некоторые переменные в пути, которые вы указываете для компилятора. Они указаны следующим образом:
```bash
$VARNAME
```
Выше будет произведена замена на значение переменной `VARNAME`.

Обычно распознается набор имен переменных, только предопределенных компилятором. В дополнение к этим именам переменных, предопределенных компилятором, можно использовать следующие обозначения
```bash
$ENVVAR$
```
для подстановки значений переменной среды. Компилятор извлечет значение `ENVVAR` из среды и заменит `$ENVVAR$` этим значением.

Компилятор определяет следующие имена переменных:
- `FPCFULLVERSION` заменяется строкой версии компилятора.
- `FPCVERSION` заменяется строкой версии компилятора.
- `FPCDATE` заменяется датой компилятора.
- `FPCTARGET` заменяется целью компилятора (комбинация CPU-OS)
- `FPCCPU` заменяется целевым процессором компилятора.
- `FPCOS` заменяется целевой ОС компилятора.

Кроме того, под Windows распознаются следующие специальные переменные:
- `LOCAL_APPDATA` Обычно каталог  *Local settings/Application Data* (Локальные настройки  Данные приложения) в домашнем каталоге пользователя.
- `APPDATA` Обычно каталог  *Application Data* (Данные приложения) в домашнем каталоге пользователя.
- `COMMON_APPDATA` Обычно каталог *Application Data* в каталоге *All users* (Все пользователи).
- `PERSONAL` Обычно каталог *My documents* (Мои документы) пользователя.
- `PROGRAM_FILES` Обычно каталог *Program files* (Программные файлы) на системном диске
- `PROGRAM_FILES_COMMON` Обычно это каталог *Common files* (Общие файлы) в каталоге программных файлов.
- `PROFILE` Домашний каталог пользователя.

Их значения могут варьироваться в зависимости от установки, они извлекаются из операционной системы.
Если ни одно из предопределенных имен переменных не было найдено, а имя шаблона заканчивается на `$`, то используется переменная среды с тем же именем:

```bash
-Fu$HOME$/FPC/currentversion/
```
Это будет относиться к каталогу `FPC/currentversion` в домашнем каталоге пользователя в Unix (`HOME` - это переменная среды, которая содержит местоположение пользовательского каталога). 

Итак, замените одну из вышеуказанных переменных, просто вставьте их с префиксом `$`, как показано ниже:

```bash
-Fu/usr/lib/fpc/$FPCVERSION/rtl/$FPCOS
```
Это эквивалентно
```bash
-Fu/usr/lib/fpc/2.6.2/rtl/linux
```
если версия компилятора 2.6.2 и целевая ОС - linux. 

Эти замены действительны в командной строке, а также в файле конфигурации. 

В командной строке linux вы должны быть осторожны, избегая `$`, поскольку в противном случае оболочка попытается расширить переменную для вас, что может привести к нежелательным последствиям.



# Глава 6

## IDE.

IDE (^eng^ **I**ntegrated **D**evelopment **E**nvironment, или ^рус^ Интегрированная Среда Разработки) обеспечивает удобный пользовательский интерфейс для компилятора. Она содержит редактор с подсветкой синтаксиса, отладчик, браузер символов и т.д. IDE - это приложение в текстовом режиме, которое одинаково выглядит и работает во всех поддерживаемых операционных системах. Она смоделирована после IDE Turbo Pascal, поэтому многие люди должны чувствовать себя комфортно, используя его.

В настоящее время IDE доступна для DOS, Windows и Linux.



### 6.1 Первые шаги в IDE.

#### 6.1.1 Запуск IDE.

Среда IDE запускается путем ввода команды: 
```bash
fp 
```
в командной строке. Ее также можно запустить из графического интерфейса пользователя, такого как Windows. 

**Примечание:** в Windows можно переключаться между оконным и полноэкранным режимом, нажав `<Alt>+<Enter>`.



#### 6.1.2 Параметры командной строки IDE.

При запуске IDE параметры командной строки могут быть переданы: 
```bash
fp [-option] [-option] ... <file name> ... 
```
Ключ `option` является одним из следующих переключателей (символы параметров не чувствительны к регистру):

- `-N` (только для DOS) Не использовать длинные имена файлов. Windows 95 и более поздние версии Windows предоставляют интерфейс приложениям DOS для доступа к длинным именам файлов. IDE использует этот интерфейс по умолчанию для доступа к файлам. При определенных обстоятельствах это может привести к проблемам. Этот переключатель предписывает IDE не использовать длинные имена файлов.
- `-Cfilename` Читать параметры IDE из `filename`. Между `filename` и ключом `-C` не должно быть пробелов.
- `-F` использовать альтернативные графические символы. Это можно использовать для запуска IDE в linux в X-term или через сеанс telnet.
- `-S` Отключить мышь. Когда эта опция используется, использование мыши отключено, даже если мышь присутствует.
- `-Tttyname` (только Linux/Unix) Отправляет вывод программы на tty ttyname. Это исключает необходимость постоянного переключения между выводом программы и IDE.

Файлы, указанные в командной строке, загружаются в окна редактирования автоматически. 

**Примечание:** в DOS/Win32 первым символом параметра командной строки может быть символ `/` вместо символа `-`. Таким образом, `/S` эквивалентно `-S`.



#### 6.1.3 Экран IDE.

После запуска экран IDE может выглядеть как на рисунке (6.1).

| Рисунок 6.1.3.1: Экран IDE сразу после запуска (Windows) |
| :------------------------------------------------------: |
|         ![](pictures/fig_6_1_fp_ide_scr_win.png)         |

|    Рисунок 6.1.3.2: Экран IDE сразу после запуска (Linux)    |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_1_fp_ide_scr_linux.png" style="zoom:105%;" /> |


В верхней части экрана отображается *строка меню*, в нижней части - *строка состояния*. Пустое пространство между ними называется *рабочим столом*.

Строка состояния отображает сочетания клавиш для часто используемых команд и обеспечивает быстрый доступ к этим командам посредством мыши. По правому краю строки состояния отображается текущий объем неиспользованной памяти. Это только отображение, поскольку среда IDE пытается выделить больше памяти из операционной системы, если ей ее не хватает.

Меню обеспечивает доступ ко всем функциям среды IDE, а в правой части меню отображаются часы.

Из IDE можно выйти, выбрав в меню `«Файл — Выход»` (что означает выбор пункта `«Выход»` в меню `«Файл»`) или нажав `<Alt>+<X>`.

**Примечание:** если в текущем каталоге обнаружен файл *fp.ans*, он загружается и используется для рисования фона. Этот файл должен содержать команды рисования ANSI для рисования на экране.



### 6.2 Навигация в IDE.

В IDE можно перемещаться как с помощью клавиатуры, так и с помощью мыши, если система оснащена мышью.



#### 6.2.1 Использование клавиатуры.

Все функциональные возможности IDE доступны через использование клавиатуры.
- Она используется для набора текста и навигации по источникам.
- Команды редактирования, такие как копирование и вставка текста.
- Перемещение и изменение размеров окон.
- Ее можно использовать для доступа к меню, нажав `<ALT>` и соответствующую выделенную букву меню, или нажав `<F10>` и перемещаясь по меню с помощью клавиш со стрелками. Более подробную информацию о меню можно найти в разделе [6.4](###6.4-Меню).
- Многие команды в среде IDE связаны с ярлыками, то есть при наборе специальной комбинации клавиш команда будет выполнена немедленно.

**Примечание:**
- При работе в Linux X-Term или в сеансе telnet комбинация клавиш с `<Alt>` может быть недоступна. Чтобы исправить это, сначала может быть нажата комбинация `<Ctrl>+<Z>`. Это означает, что, например, `<Alt>+<X>` можно заменить на `<Ctrl>+<Z>+<X>`.
- Кроме того, вы можете попробовать комбинацию клавиш `<ESC>+<X>` для `<Alt>+<X>` при работе на Linux.
- Полный список всех сочетаний клавиш можно найти в разделе [6.14](###6.14-Сочетания-клавиш).



#### 6.2.2 Использование мыши.

Если система оснащена мышью, ее можно использовать для работы с IDE. Левая кнопка используется для выбора пунктов меню, нажатия кнопок, выбора текстовых блоков и т.д.

Правая кнопка мыши используется для доступа к локальному меню, если оно доступно. Удерживая нажатой клавишу `<Ctrl>` или `<Alt>` и нажимая правую кнопку, вы выполните предопределенные пользовательские функции. См. раздел [6.12.4](####6.12.4-Клавиатура-и-мышь).

**Примечание:**
1. Иногда в руководстве используется термин «перетаскивание мышью». Это означает, что мышь перемещается, пока нажата левая кнопка мыши.
2. Действие кнопок мыши может быть отменено, то есть действия левой кнопки мыши могут быть назначены правой кнопке мыши и наоборот (см. раздел [6.12.4](####6.12.4-Клавиатура-и-мышь) для получения дополнительной информации о том, как отменить действия кнопок мыши.). Во всем руководстве предполагается, что действия кнопок мыши не отменяются.
3. Мышь не всегда доступна, даже если она установлена:
    - IDE работает под Linux через соединение telnet с компьютера с Windows.
    - IDE работает под Linux в X-термине под X-windows. В этом случае это зависит от программы терминала: под Konsole (терминал KDE) он работает.
4. В Windows консоль имеет параметр «Быстрое редактирование», позволяющий копировать текст в буфер обмена, выбрав текст в окне консоли. Если этот режим включен, работать мышь не будет. Параметр «Быстрое редактирование» должен быть отключен в свойствах окна консоли, чтобы среда IDE могла получать события мыши.



#### 6.2.3 Навигация в диалогах.

Диалоги обычно содержат много элементов, таких как кнопки, поля редактирования, поля заметок, списки и т.д. Чтобы активировать одно из этих полей, выберите один из следующих методов:
1. Нажмите на элемент с помощью мыши.
2. Нажимайте клавишу `<Tab>`, пока фокус не достигнет элемента.
3. Нажмите выделенную букву на ярлыке элемента. Если в данный момент фокус находится на элементе, который позволяет редактировать, тогда `<Alt>` следует нажимать одновременно с выделенной буквой. Для кнопки будет выполнено действие, связанное с кнопкой.

Внутри полей редактирования, списков и заметок навигация осуществляется с помощью обычных команд клавиш со стрелками.



### 6.3 Окно.

В настоящее время работа с оконными приложениями не должна быть проблемой для большинства пользователей Windows и Linux. Тем не менее, в следующем разделе описывается, как работают окна, чтобы извлечь максимальную выгоду из Free Pascal IDE.



6.3.1 Основное окно.

Общее окно IDE показано на рисунке 6.3.1.1

|                Рисунок 6.3.1.1 Общее окно IDE                |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_3_fp_common_ide_window.png" style="zoom:120%;" /> |

Окно окружено так называемой рамой, белой двойной линией вокруг окна.

В верхней части окна отображаются 4 вещи:
- В верхнем левом углу окна отображается значок закрытия. При нажатии окно будет закрыто.
- Его также можно закрыть, нажав Alt-F3 или выбрав пункт меню `<Window—Close>`(Окно - Закрыть). Все открытые окна можно закрыть, выбрав пункт меню `<Window—Close all>`(Окно - Закрыть все). В середине отображается заголовок окна.
- Почти в правом верхнем углу номер виден. Этот номер идентифицирует окно редактора, и нажатие `<Alt>+<Number>` перейдет в это окно. Только первые 9 окон получат такой номер.
- В верхнем правом углу видна маленькая зеленая стрелка. Нажатие на эту стрелку увеличивает окно, чтобы оно покрыло весь рабочий стол. Нажатие на эту стрелку в увеличенном окне восстановит старый размер окна. Нажатие клавиши `<F5>` имеет тот же эффект, что и нажатие на эту стрелку. Этого же эффекта можно достичь с помощью пункта меню `<Window—Zoom>`(Окно - Масштаб). Окна и диалоги, размер которых нельзя изменить, также нельзя увеличить.

Правый край и нижний край окна содержат полосы прокрутки. Их можно использовать для прокрутки содержимого окна с помощью мыши. Стрелки на концах полос прокрутки можно нажимать для прокрутки содержимого построчно. Нажатие на пунктирную область между стрелками и прямоугольником голубого цвета прокручивает содержимое окна постранично. Перетаскивая прямоугольник, содержимое можно прокручивать непрерывно.

Звездочка и цифры в левом нижнем углу окна отображают информацию о содержимом окна. Они объяснены в разделе о редакторе, см. раздел [6.5](###6.5-Редактирование-текста.).



#### 6.3.2 Изменение размеров и перемещение окон.

Окно можно перемещать и изменять размер с помощью мыши и клавиатуры.

Чтобы переместить окно: 
- используя мышь, щелкните строку заголовка и перетащите окно мышью.
- с помощью клавиатуры перейдите в режим изменения размера/перемещения, нажав `<Ctrl>+<F5>` или выбрав пункт меню `<Window—Size/Move>`(Окно - Размер/Переместить). Рамка окна изменится на зеленый, чтобы указать, что IDE находится в режиме изменения размера/перемещения. Теперь клавиши курсора можно использовать для перемещения окна. Нажмите `<Enter>`, чтобы выйти из режима изменения размера/перемещения. В этом случае окно сохранит свой размер и положение. Кроме того, нажатие клавиши `<Esc>` восстановит старую позицию.

Чтобы изменить размер окна:
- используя мышь, щелкните в правом нижнем углу окна и перетащите его.
- с помощью клавиатуры перейдите в режим размер/перемещение, нажав `<Ctrl<+<F5>` или выбрав пункт меню `Window—Size/Move`(Окно - Размер/Переместить). Рамка окна изменится на зеленый, чтобы указать, что IDE находится в режиме размера/перемещения. Теперь, удерживая клавишу `<SHIFT>`, нажмите одну из клавиш курсора, чтобы изменить размер окна. Нажмите `<Enter>`, чтобы выйти из режима изменения размера/перемещения. Нажатие `<Esc>` восстановит старый размер.

Не все окна могут быть изменены. Это относится, например, к *диалоговым окнам* (раздел [6.3.4](####6.3.4-Диалоговые-окна)). 

Окно также может быть скрыто. Чтобы скрыть окно, можно использовать комбинацию клавиш `<Ctrl>+<F6>` или выбрать меню `<Window—Hide>`(Окно - Скрыть). Чтобы восстановить скрытое окно, необходимо выбрать его из списка окон. Более подробную информацию о списке окон можно найти в следующем разделе.



#### 6.3.3 Работа с несколькими окнами.  

При работе с более крупными проектами вполне вероятно, что на рабочем столе появится несколько окон. Однако только одно из этих окон будет активным окном; все остальные окна будут неактивными. 

Неактивное окно обозначается серой рамкой. Неактивное окно можно сделать активным одним из нескольких способов:
- используя мышь, активируйте окно, нажав на него.
- при использовании клавиатуры нажатие `<F6>` будет проходить через все открытые окна. Чтобы активировать ранее активированное окно, можно использовать `<Shift>+<F6>`.
- пункт меню `Window—Next`(Окно - Далее) можно использовать для активации следующего окна в списке окон, тогда как Окно | Предыдущий выберет предыдущее окно.
Если у окна есть номер в правом верхнем углу, его можно активировать, нажав Alt- <число>.
Нажатие Alt-0 вызовет диалог со всеми доступными окнами, который позволяет быстро активировать окна, у которых нет номера.

Окна могут быть упорядочены и размещены на рабочем столе IDE путем масштабирования и изменения их размера с помощью мыши или клавиатуры. Это трудоемкая задача, особенно сложная с клавиатурой. Вместо этого можно использовать пункты меню «Окно-плитка» и «Окно-каскад»:
Плитка будет равномерно распределять все пространство рабочего стола между всеми окнами с изменяемым размером.
Каскад ставит все окна в каскадное расположение. В очень редких случаях экран IDE может запутаться. В этом случае весь экран IDE можно обновить, выбрав пункт меню «Окно - Обновить отображение».




#### 6.3.4 Диалоговые окна.

Во многих случаях в среде IDE отображается диалоговое окно для получения пользовательского ввода. Основное отличие от обычных окон состоит в том, что другие окна не могут быть активированы, когда диалог активен. Также меню недоступно во время диалога. Такое поведение называется модальным. Чтобы активировать другое окно, модальное окно или диалог должны быть закрыты в первую очередь.

Типичное диалоговое окно показано на рисунке (6.3.4.1).

|           рисунок 6.3.4.1 Типичное диалоговое окно           |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_3_window_dlg.png" style="zoom:150%;" /> |



### 6.4 Меню.

Главное меню (серая полоска в верхней части IDE) обеспечивает доступ ко всем функциям IDE. Он также содержит часы, отображающие текущее время. Меню всегда доступно, кроме случаев, когда открыто диалоговое окно. Если диалоговое окно открыто, оно должно быть сначала закрыто для доступа к меню.

В некоторых окнах также доступно локальное меню. Локальное меню появляется там, где находится курсор, и предоставляет дополнительные команды, которые зависят от контекста.



#### 6.4.1 Доступ к меню.

Доступ к меню можно получить несколькими способами:
1. с помощью мыши при выборе пункта меню. Курсор мыши должен быть расположен над нужным пунктом меню, затем щелчок левой кнопкой мыши выберет его.
2. нажитием `<F10>`. Это переключит фокус IDE на меню. Для навигации в меню могут быть использованы клавиши со стрелками. Клавиша `<Enter>` должна использоваться для выбора пунктов.
3. для прямого доступа к элементам меню может использоваться `<Alt>+<подсвеченная буква меню>` для выбора пункта меню. Впоследствии пункты подменю можно выбрать нажатием выделенной буквы, но без `<Alt>`. Например, `<Alt>+<S>` `<G>` - это быстрый способ отобразить диалог перехода к строке.

Каждый пункт меню поясняется коротким текстом в строке состояния.

Когда доступно локальное меню, к нему можно обратиться, нажав правую кнопку мыши или `<Alt>+<F10>`.

Чтобы выйти из любого меню без каких-либо действий, дважды нажмите клавишу `<ESC>`.

Далее описаны все пункты меню и их действия.



#### 6.4.2 Меню File.

Меню `File`(Файл) содержит все пункты меню, которые позволяют пользователю загружать и сохранять файлы, а также выходить из IDE.
- `New`(Новый) Открывает новое пустое окно редактора.
- `New from template`(Создать из шаблона) Запрашивает использование шаблона, спрашивая заполнение любых параметров, а затем запускает новое окно редактора с шаблоном.
- `Open(F3)`(Открыть)  Представляет диалоговое окно выбора файла и открывает выбранный файл в новом окне редактора.
- `Print`(Печать) Распечатывает содержимое текущего окна редактирования.
- `Print setup`(Настройка печати) Настраивает свойства принтера. 
- `Reload`(Перезагрузка) Перезагружает файл с диска.
- `Save(F2)`(Сохранить) Сохраняет содержимое текущего окна редактирования с текущим именем файла. Если текущее окно редактирования еще не имеет имени файла, открывается диалоговое окно для ввода нового имени файла.
- `Save as`(Сохранить как) Предоставляет диалог, в котором можно ввести имя файла. Содержимое текущего окна затем сохраняется в это новое имя файла, а имя файла сохраняется для дальнейших действий сохранения.
- `Save all`(Сохранить все) Сохраняет содержимое всех окон редактирования.
- `Change dir`(Cменить каталог) Предоставляет диалоговое окно, в котором можно выбрать каталог. Текущий рабочий каталог затем изменяется на выбранный каталог.
- `Command shell`(Командная оболочка) Запускает командную оболочку. После выхода из оболочки работа среды возобновляется. Какая командная оболочка выполняется, зависит от системы.
- `Exit(ALT-X)` (Выход)  Выход из IDE. Если в редакторе есть несохраненные файлы, в среде IDE будет предложено сохранить эти файлы.

Под меню `Exit`(Выход) отображаются некоторые имена недавно использованных файлов. Эти записи могут быть использованы для быстрой перезагрузки этих файлов в редакторе.



#### 6.4.3 Меню Edit.

Меню `Edit`(Редактировать) содержит записи для доступа к буферу обмена и отмены или повторения действий редактирования. Большинство из этих функций имеют сочетания клавиш, связанные с ними.
- `Undo(ALT-BKSP)`(Отменить) Отменяет эффект последнего действия редактирования. Действия редактирования хранятся в буфере. Выбор этого механизма будет перемещаться назад через этот буфер, то есть возможно несколько уровней отмены. Тем не менее, произвольно выбранные варианты не воспроизводятся.
- `Redo`(Повторить) Повторяет последнее действие, которое было только что отменено при отмене. `Redo` может повторить несколько отмененных действий.
- `Cut(Shift-DEL)`(Вырезать) Удаляет выделенный текст из окна и копирует его в буфер обмена. Любое предыдущее содержимое буфера обмена затирается. Новое содержимое буфера обмена доступно для вставки в другом месте.
`Copy(Ctrl-INS)`(Копировать) Копирует текущий выбор в буфер обмена. Любое предыдущее содержимое буфера обмена затирается. Новое содержимое буфера обмена доступно для вставки в другом месте.
- `Copy (Shift-INS)`(Вставить) Вставляет текущее содержимое буфера обмена в текст в позиции курсора. Содержимое буфера обмена остается прежним.
- `Clear(Ctrl-DEL)`(Очистить) Очищает (т.е. удаляет) текущий выбор.
- `Select All`(Выбрать все) Выбирает весь текст в текущем окне. Выбранный текст может быть затем вырезан или скопирован в буфер обмена.
- `Unselect` (Отменить выбор) Отменяет выбор.
- `Show clipboard`(Показать буфер обмена) Открывает окно, в котором отображается текущее содержимое буфера обмена.

При запуске IDE под Windows в меню `Edit`(Редактировать) есть две дополнительные записи. В среде IDE имеется отдельный буфер обмена, который не разделяет его содержимое с буфером обмена Windows. Для доступа к буферу обмена Windows также существуют следующие две записи:
- `Copy to Windows`(Копировать в Windows) Скопировать выделенную область в буфер обмена Windows.
- `Paste from Windows`(Вставить из Windows) Вставляет содержимое буфера обмена Windows (если оно содержит текст) в окне редактирования в текущей позиции курсора.



#### 6.4.4 Меню Search.

Меню `Search`(Поиск) обеспечивает доступ к диалогам поиска и замены, а также к браузеру символов в среде IDE.
- `Find(Ctrl-Q F)`(Найти) Представляет диалоговое окно поиска. Можно ввести текст для поиска, и когда диалоговое окно закрывается, введенный текст ищется в активном окне. Если текст найден, он будет выбран.
- `Replace(Ctrl-Q A)`(Заменить) Представляет диалог поиска и замены. После закрытия диалога текст поиска будет заменен текстом замены в активном окне.
- `Search again (CTRL-L)`(Искать заново) Повторяет последний поиск или поиск и замену действия, используя те же параметры.
- `Go to line number (Alt-G)`(Перейти к номеру строки) Запрашивает номер строки, а затем переходит к этому номеру строки.
Когда программа и модули скомпилированы с информацией для просмотра, включаются также следующие пункты меню:
- `Find procedure`(Поиск процедуры) Еще не реализована.
- `Objects`(Объекты) Запрашивает имя объекта и открывает окно просмотра для этого объекта.
- `Modules`(Модули) Запрашивает имя модуля и открывает окно просмотра для этого модуля.
- `Globals`(Общий) Запрашивает имя глобального символа и открывает окно просмотра для этого глобального символа. 
- `Symbol`(Символ) Открывает окно со всеми известными символами, в котором можно выбрать символ. После выбора символа открывается окно просмотра этого символа.



#### 6.4.5 Меню Run.

Меню `Run`(Выполнить) содержит все записи, связанные с запуском программы.
- `Run (Ctrl-F9)`(Выполнить) Если исходные коды были изменены, компилируется программа. Если компиляция прошла успешно, программа выполняется. Если первичный файл был задан, то он используется для определения, какую программу выполнять. См. раздел [6.4.6](####6.4.6-Меню-Compile) для получения дополнительной информации о том, как задать первичный файл.
- `Step over (F8)`(Шаг вперед) Запускает программу, пока не будет достигнута следующая строка исходника. Если будут сделаны какие-либо вызовы процедур, они также будут выполнены полностью.
- `Trace into (F7)`(Трассировка вглубь) Если текущая строка содержит вызов другой процедуры, процесс остановится в точке входа вызываемой процедуры.
- `Goto cursor (F4)`(Курсор перехода) Выполняет программу, пока точка выполнения не совпадет со строкой, в которой находится курсор.
- `Until return`(До возврата) Запускает текущую процедуру до ее выхода.
- `Run directory`(Каталог запуска) Задает рабочий каталог, в который нужно перейти при выполнении программы.
- `Parameters`(Параметры) Позволяет вводить параметры, которые будут переданы программе при ее выполнении.
- `Program reset(Ctrl-F2)`(Сброс программы) Если программа запускается или отлаживается, сеанс отладки прерывается, а запущенная программа уничтожается.



#### 6.4.6 Меню Compile.

Меню `Compile`(Компиляция) содержит все записи, связанные с компиляцией программы или модуля.
- `Compile (Alt-F9)`(Компилировать) Компилирует содержимое активного окна независимо от настроек основного файла.
- `Make (F9)`(Сделать) Компилирует содержимое активного окна и любые файлы, от которых зависит модуль или программа и которые были изменены с момента последней компиляции. Если основной файл был задан, вместо этого компилируется основной файл.
- `Build`(Сборка) Компилирует содержимое активного окна и любые файлы, от которых зависит модуль или программа, независимо от того, были ли они изменены или нет. Если основной файл был задан, основной файл компилируется вместо этого.
- `Target`(Цель) Устанавливает целевую операционную систему, для которой программа должна быть скомпилирована.
- `Primary file`(Основной файл) Задает основной файл. Если он задан, любая команда запуска или компиляции будет действовать на основной файл, а не на активное окно. Основной файл не нужно загружать в IDE, чтобы это имело эффект.
- `Clear primary file`(Очистить основной файл) Очищает основной файл. После этой команды любое действие запуска или компиляции будет действовать в активном окне.
- `Compiler messages (F12)`(Сообщения компилятора) Отображает окно сообщений компилятора. В этом окне будут отображаться сообщения, сгенерированные компилятором во время самой последней компиляции.



#### 6.4.7 Меню Debug.

Меню `Debug`(Отладка) содержит пункты меню, помогающие в отладке программы, такие как установка точек останова и наблюдения.
- `Output`(Выходные данные) Показывает вывод программы пользователя в окне.
- `User screen (Alt-F5)`(Экран пользователя) Переключение на экран в том виде, в котором он был оставлен запущенной программой в последний раз.
- `Add watch (Ctrl-F7)`(Добавить отслеживание) Добавляет отслеживание. Отслеживание - это выражение, которое может быть оценено средой IDE и будет показано в специальном окне. Обычно это содержимое некоторой переменной.
- `Watches`(Отслеживание) Показывает текущий список отслеживания в отдельном окне.
- `Breakpoint (Ctrl-F8)`(Точка останова) Устанавливает точку останова на текущей строке. При отладке выполнение программы остановится на этой точке останова.
- `Breakpoint list`(Список точек останова) Показывает текущий список точек останова в отдельном окне.
- `Evaluate Call stack (Ctrl-F3)`(Оценить стек вызовов) Показывает стек вызовов. Стек вызовов - это список адресов (и имен файлов, и номеров строк, если эта информация была скомпилирована) процедур, которые в данный момент вызываются запущенной программой.
- `Disassemble`(Дисассемблирование) Показывает стек вызовов.
- `Registers`(Регистры) Показывает текущее содержимое регистров процессора.
- `Floating point unit`(Модуль с плавающей точкой) Показывает текущее содержимое регистров FPU.
- `Vector unit`(Модуль вектора) Показывает текущее содержимое регистров MMX (или эквивалентных).
- `GDB window`(Окно отладчика GDB) Показывает консоль отладчика GDB. Это может быть использовано для непосредственного взаимодействия с отладчиком; здесь можно ввести произвольные команды GDB, и результат будет показан в окне.



#### 6.4.8 Меню Tools.

Меню `Tools`(Инструменты) определяет некоторые стандартные инструменты. Если пользователь определяет новые инструменты, они также добавляются в это меню.
- `Messages (F11)`(Сообщения) Показывает окно сообщений. Это окно содержит выходные данные одного из инструментов. Для получения дополнительной информации см. раздел [6.10.1](####6.10.1-Окно-сообщений).
- `Goto next (Alt-F8)`(Перейти к следующему) Переход к следующему сообщению.
- `Goto previous (Alt-F7)`(Перейти к предыдущему) Переход к предыдущему сообщению.
- `Grep (SHIFT-F2)` Запрашивает регулярное выражение и параметры для `grep`, а затем выполняет `grep` с заданным выражением и параметрами. Чтобы это работало, программа grep должна быть установлена в системе и находиться в каталоге, который находится в PATH. Для получения дополнительной информации см. раздел [6.10.2](####6.10.2-Grep).
- `Calculator`(Калькулятор) Отображает калькулятора. Для получения дополнительной информации см. раздел [6.10.4](####6.10.4-Калькулятор).
- `ASCII table`(Таблица ASCII) Отображает таблицу ASCII. Для получения дополнительной информации см. раздел [6.10.3](####6.10.3-Таблица ASCII).



#### 6.4.9 Меню Options.

Меню `Options`(Параметры) является точкой входа для всех диалогов, которые используются для установки параметров компилятора и IDE, а также пользовательских настроек.
- `Mode`(Режим) Представляет диалоговое окно для установки текущего режима компилятора. Текущий режим отображается справа от пункта меню. Для получения дополнительной информации см. раздел [6.11.8](####6.11.8-Режимы-переключения).
- `Compiler`(Компилятор) Представляет диалоговое окно, которое можно использовать для установки общих параметров компилятора. Эти параметры будут использоваться при компиляции программы или модуля.
- `Memory sizes`(Размеры памяти) Представляет диалоговое окно, в котором можно задать размер стека и размер кучи для программы. Эти параметры будут использоваться при компиляции программы.
- `Linker`(Компоновщик) Представляет диалоговое окно, в котором можно установить некоторые параметры компоновщика. Эти параметры будут использоваться при компиляции программы или библиотеки.
- `Debugger`(Отладчик) Представляет диалог, в котором можно установить параметры отладки. Эти параметры используются при компиляции модулей или программ. Обратите внимание, что отладчик не будет работать, если для программы не сгенерирована отладочная информация.
- `Directories`(Каталоги) Представляет диалог, в котором можно установить различные каталоги, необходимые компилятору. Эти каталоги будут использоваться при компиляции программы или модуля.
- `Browser`(Браузер) Представляет диалог, в котором можно установить параметры браузера. Параметры браузера влияют на поведение браузера символов в среде IDE.
Инструменты Представляет диалог для настройки меню инструментов. Для получения дополнительной информации см. раздел [6.10.5](####6.10.5-Добавление-новых-инструментов).
- `Environment`(Окружение) Представляет диалоговое окно для настройки поведения среды IDE. Подменю представлено с различными аспектами IDE:
    - `Preferences`(Предпочтения) Общие предпочтения, например, сохранять ли файлы автоматически или нет, и какие файлы следует сохранять. Режим видео также можно установить здесь.
    - `Editor`(Редактор) Управляет различными аспектами окон редактирования.
    - `CodeComplete`(Автозавершение кода) Используется для установки слов, которые могут быть автоматически завершены при наборе текста в окнах редактора.
    `Codetemplates`(Шаблоны кода) Используется для определения шаблонов кода, которые можно вставить в окно редактирования.
    `Desktop`(Рабочий стол) Используется для управления поведением рабочего стола, т.е. некоторые функции могут быть включены или выключены.
    `Keyboard & Mouse`(Клавиатура и мышь) Может использоваться для выбора соглашения cut/copy/paste, управления действиями мыши и назначения команд различным действиям мыши.
    `Learn keys`(Изучение клавиш) Позволяет среде IDE изучать нажатия клавиш для назначения различным командам. Это полезно в основном на Linux и Unix-подобных платформах, где фактические ключи, отправляемые в IDE, зависят от эмуляции терминала.
- `Open`(Открыть) Представляет диалоговое окно, в котором можно выбрать файл, содержащий настройки редактора. После закрытия диалога файл настроек будет прочитан и настройки будут применены.
- `Save`(Сохранить) Сохраняет текущие параметры в файле по умолчанию.
- `Save as Saves`(Сохранить как) Сохраняет текущие параметры в альтернативном файле. Откроется диалоговое окно выбора файла, в котором можно указать альтернативный файл настроек.

Обратите внимание, что параметры не сохраняются автоматически. Они должны быть сохранены в явном виде с помощью команды `Options—Save`(Параметры — Сохранить).



#### 6.4.10 Меню Window.

Меню `Window`(Окно) предоставляет доступ к некоторым функциям окна. Более подробную информацию обо всех этих функциях можно найти в разделе [6.3](###6.3-Окно).
- `Tile`(Плитка) Отображение всех открытых окон на рабочем столе плиткой.
- `Cascade`(Каскад) Отображение всех открытых окон на рабочем столе каскадом.
- `Close all`(Закрыть все) Закрывает все открытые окна.
- `Size/move (Ctrl-F5)`(Размер/перемещение) Переводит IDE в режим изменения размера/перемещения; после этой команды активное окно может быть перемещено и изменено с помощью клавиш со стрелками.
- `Zoom (F5)`(Масштаб) Увеличение или уменьшение текущего окна.
- `Next (F6)`(Далее) Активирует следующее окно в списке окон.
- `Previous (SHIFT-F6)`(Предыдущий) Активирует предыдущее окно в списке окон.
- `Hide (Ctrl-F6)`(Скрыть) Скрывает активное окно.
- `Close (ALT-F3)`(Закрыть) Закрывает активное окно.
- `List (Alt-0)`(Список) Показывает список открытых окон. Оттуда окно может быть активировано, закрыто, показано и скрыто.
- `Refresh display`(Обновить дисплей) Перерисовывает экран.



6.4.11 Меню Help.

Меню `Help`(Справка) предоставляет точки входа для всех функций справки в среде IDE, а также средства для настройки справочной системы.
- `Contents`(Содержание) Показывает содержание справки.
- `Index (SHIFT-F1)`(Индекс) Перейти к справке Index.
- `Topic search (CTRL-F1)`(Поиск по теме) Переход к теме, связанной с выделенным в данный момент текстом.
- `Previous topic (ALT-F1)`(Предыдущая тема) Переход к ранее посещенной теме.
- `Using help`(Использование справки) Отображение справки по использованию справочной системы.
- `Files`(Файлы) Позволяет настроить меню справки. С помощью этого пункта меню файлы справки могут быть добавлены в справочную систему.
- `About`(О программе) Отображает информацию об IDE. См. раздел [6.13.3](####6.13.3-Диалог-about) для получения дополнительной информации.


### 6.5 Редактирование текста.

В этом разделе объясняются основы редактирования (исходного) текста. В этом отношении IDE работает, как и многие другие текстовые редакторы, поэтому в основном будут объяснены отличительные особенности IDE.


#### 6.5.1 Режимы вставки.

Обычно IDE находится в режиме вставки. Это означает, что любой набранный текст будет вставлен перед текстом, который присутствует после курсора.
В режиме перезаписи любой набранный текст заменит существующий текст.
В режиме вставки курсор представляет собой плоскую мигающую линию. Если среда IDE находится в режиме перезаписи, курсор представляет собой куб с высотой в одну строку. Переключение между режимом вставки и режимом перезаписи происходит с помощью клавиши вставки или клавиши `<Ctrl>+<V>`.


#### 6.5.2 Блоки.

IDE обрабатывает выделенный текст так же, как Turbo Pascal IDE. Это немного отличается от способа, которым, например, приложения Windows обрабатывают выделенный текст. 

Текст можно выделить тремя способами:
    1. С использованием мышь, перетаскивая мышку на существующий текст, выделив его.
    2. С помощью клавиатуры, нажав `<Ctrl-K>+<B>`, чтобы отметить начало выделенного текста, и `<Ctrl-K>+<K>`, чтобы отметить конец выделенного текста.
    3. С использованием клавиатуры, удерживая нажатой клавишу `<Shift>` во время навигации с помощью клавиш курсора.

Есть также несколько специальных команд выбора:
    1. Текущая строка может быть выбрана с помощью `<Ctrl-K>+<L>`.
    2. Текущее слово можно выбрать с помощью `<Ctrl-K>+<T>`.

В Free Pascal IDE выделенный текст является постоянным. После выбора диапазона текста курсор можно переместить, и выделение не будет уничтожено; следовательно, термин «блок» больше подходит для выбора и будет использоваться отныне ...

В одном блоке можно выполнить несколько команд:
    - Переместить блок в позицию курсора (`<Ctrl-K>+<V>`).
    - Скопировать блок в местоположение курсора (`<Ctrl-K>+<C>`).
    - Удалить блок (`<Ctrl-K>+<Y>`).
    - Записать блок в файл (`<Ctrl-K>+<W>`).
    - Прочесть содержимое файла в блок (`<Ctrl-K>+<R>`). Если блок уже существует, этот блок не заменяется этой командой. Файл вставляется в текущей позиции курсора, а затем вставленный текст выделяется.
    - Сделать отступ для блока (`<Ctrl-K>+<I>`).
    - Отменить отступ блока (`<Ctrl-K>+<U>`).
    - Распечатать содержимое блока (`<Ctrl-K>+<P>`).

При поиске и замене поиск может быть ограничен содержимым блока.


#### 6.5.3 Настройка закладок.

В среде IDE есть функция, позволяющая установить закладку в текущей позиции курсора. Позже курсор можно вернуть в эту позицию, нажав сочетание клавиш.

Можно установить до 9 закладок на исходный файл; они устанавливаются с помощью `<Ctrl-K>+<Number>` (где `number` - номер закладки). Чтобы перейти к ранее установленной закладке, нажмите `<Ctrl-Q>+<Number>`.

**Примечание**. В настоящее время закладки не сохраняются при выходе из среды IDE. Это может измениться в будущих реализациях IDE.


#### 6.5.4 Переход к исходной строке.

Можно перейти непосредственно к конкретной строке источника. Для этого откройте диалоговое окно `Goto line number`(Перейти к строке) в меню `Search—Goto line number`(Поиск - номер строки перехода).

В появившемся диалоговом окне можно ввести номер строки, к которой должна перейти IDE. Диалог перехода к строке показан на рисунке 6.4

|                 Рисунок 6.4 Диалог goto line                 |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_4_goto_line_dlg.png" style="zoom:80%;" /> |



#### 6.5.5 Подсветка синтаксиса.

В среде IDE предусмотрена возможность подсветки синтаксиса, т.е. цвет некоторых элементов Pascal может быть установлен. Когда текст вводится в окне редактора, IDE попытается распознать элементы и соответственно установить цвет текста.
Подсветка синтаксиса может быть настроена в диалоге настроек цвета с помощью пункта меню `Options—Environment—Colors`(Параметры—Среда—Цвета). В диалоговом окне цветов должна быть выбрана группа `Syntax`(Синтаксис). Затем список элементов будет отображать различные синтаксические элементы, которые можно раскрасить:

- `Whitespace`(Пробел) Пустой текст между словами. Обратите внимание, что для пробелов будет использоваться только цвет фона.
- `Comments`(Комментарии) Все стили комментариев в Free Pascal.
- `Reserved words`(Зарезервированные слова) Все зарезервированные слова Free Pascal (см. также  [Reference Guide](https://www.freepascal.org/docs-html/current/ref/ref.html)).
- `Strings`(Строки) Постоянные строковые выражения.
- `Numbers`(Числа) Числа в десятичной записи.
- `Hex numbers`(Шестнадцатеричные числа) Числа в шестнадцатеричной записи.
- `Assembler`(Ассемблер) Любые ассемблерные блоки.
- `Symbols`(Символы)  Распознанные символы (переменные, типы). 
- `Directives`(Директивы) Директивы компилятора.
- `Tabs`(Вкладки) Символы табуляции в источнике могут иметь другой цвет, чем другие пробелы.

Редактор использует некоторые настройки по умолчанию, но эксперименты - лучший способ найти подходящую цветовую схему. Хорошая цветовая схема помогает обнаруживать ошибки в источниках, поскольку ошибки приводят к неправильной подсветке синтаксиса.


#### 6.5.6 Автозавершение кода.

Автозавершение кода означает, что редактор попытается угадать текст по мере его ввода. Это делается путем проверки того, какой текст набирается, и как только набранный текст может быть использован для идентификации ключевого слова в списке ключевых слов, ключевое слово будет представлено в небольшом цветном поле под напечатанным текстом. Нажатие клавиши `<Enter>` завершит слово в тексте.

Пока нет завершения кода для заполнения аргументов функции или выбора методов объекта, как, например, Lazarus или Delphi IDE.

Завершение кода можно настроить в диалоговом окне «Завершение кода», доступном через пункт меню `Options—Preferences—Codecomplete`(Параметры — Предпочтения — Автозавершение кода). Список ключевых слов, которые можно автоматически завершить, можно сохранить здесь. Диалог завершения кода показан на рисунке (6.5).

|       Рисунок 6.5 Диалоговое окно автозавершения кода        |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_5_code_compl_dlg.png" style="zoom:90%;" /> |


Диалог показывает в алфавитном порядке определенные в настоящее время ключевые слова, которые доступны для автозавершения. Доступны следующие кнопки:

- `ОК` Сохраняет все изменения и закрывает диалог.
- `Edit`(Изменить) Открывает диалоговое окно, которое позволяет редактировать выделенное в данный момент ключевое слово.
- `New`(Новое) Открывается диалоговое окно, в котором можно ввести новое ключевое слово, которое будет добавлено в список.
- `Delete`(Удалить) Удаляет текущее выделенное ключевое слово из списка.
- `Cancel`(Отмена) Отменяет все изменения и закрывает диалог.

Все ключевые слова сохранены и доступны при следующем запуске IDE. Дубликаты имен не допускаются. Если будет сделана попытка добавить повторяющееся имя в список, появится ошибка.


#### 6.5.7 Шаблоны кода.

Шаблоны кода - это способ вставки больших кусков кода одновременно. Каждый шаблон кода идентифицируется уникальным именем. Это имя можно использовать для вставки связанного фрагмента кода в текст.

Например, имя шаблона `ifthen` может быть связано со следующим фрагментом кода:
```pascal
if | then  
  begin  
  end
```
Шаблон кода можно вставить, введя его имя и нажав `<Ctrl-J>`, когда курсор расположен сразу после имени шаблона.

Если перед курсором нет имени шаблона, появится диалоговое окно, позволяющее выбрать шаблон.

Если в шаблоне кода присутствует вертикальная черта (`|`), на него помещается курсор и вертикальная черта удаляется. В приведенном выше примере курсор будет расположен между `if` и `then`, готовым ввести выражение.

Шаблоны кода можно добавлять и редактировать в диалоге шаблонов кода, доступном через пункт меню `Options—Environment—CodeTemplates`(Параметры—Среда—Шаблоны кода). Диалог шаблонов кода показан на рисунке (6.6).

|          Рисунок 6.6 Диалоговое окно шаблонов кода           |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_6_code_templates_dlg.png" style="zoom:90%;" /> |

В верхнем списке в диалоге шаблонов кода отображаются имена всех известных шаблонов. В нижней половине диалогового окна отображается текст, связанный с выделенным в данный момент шаблоном кода. Доступны следующие кнопки:

- `ОК` Сохраняет все изменения и закрывает диалог.
- `Edit`(Редактировать) Всплывающее диалоговое окно, которое позволяет редактировать выделенный в данный момент шаблон кода. И имя, и текст могут быть отредактированы.
- `New`(Новый) Открывается диалоговое окно, в котором можно ввести новый шаблон кода, который будет добавлен в список. Имя должно быть введено для нового шаблона.
- `Delete`(Удалить) Удаляет выделенный в данный момент шаблон кода из списка.
- `Cancel`(Отмена) Отменяет все изменения и закрывает диалог.

Все шаблоны сохраняются и будут доступны при следующем запуске IDE.

**Примечание:** дубликаты не допускаются. Если попытаться добавить повторяющееся имя в список, произойдет ошибка.


### 6.6 Поиск и замена.

Среда IDE позволяет искать текст в активном окне редактора. Для поиска текста можно выполнить одно из следующих действий:
1. Выберите `Search—Find`(Поиск-Найти) в меню.
2. Нажмите `<Ctrl-Q>+<F>`.

После этого появится диалоговое окно, показанное на рисунке (6.7), и можно будет ввести следующие параметры:

|  Рисунок 6.7 Диалоговое окно поиска  |
| :----------------------------------: |
| ![](pictures/fig_6_7_search_dlg.png) |

- `Text to find`(Текст для поиска) Если блок был активен при запуске диалога, предлагается первая строка этого блока.
- `Case sensitive`(Регистрозависимый) Если этот флажок установлен, поиск чувствителен к регистру.
- `Whole words only`(Только целые слова) Если этот флажок установлен, текст для поиска должен определяться в искомом тексте как полное слово.
- `Direction`(Направление поиска) Направление, в котором должен выполняться поиск, начиная с указанного источника.
- `Scope`(Область) Указывает, должен ли поиск выполняться по всему файлу или только по выделенному тексту.
- `Origin`(Источник) Указывает, должен ли поиск начинаться с позиции курсора или с начала области.

После закрытия диалога поиск выполняется с использованием заданных параметров.

Поиск можно повторить (используя те же параметры) одним из двух способов:
1. Выбрать `Search—Search again`(Поиск-Поиск снова) в меню.
2. Нажать `<Ctrl-L>`.

Также возможно заменить вхождения текста другим текстом. Это можно сделать аналогично поиску текста:
1. Выбрать `Search—Replace`(Поиск-Заменить) в меню.
2. Нажать `<Ctrl-Q>+<A>`.

Появится диалоговое окно, похожее на диалоговое окно поиска, как показано на рисунке (6.8).

| Рисунок 6.8 Диалоговое окно замены текста |
| :---------------------------------------: |
|   ![](pictures/fig_6_8_replace_dlg.png)   |


В этом диалоговом окне, в дополнение к возможностям диалогового окна поиска, можно ввести следующие вещи:
- `New text`(Новый текст) Текст, который заменит найденный текст.
- `Prompt on replace`(Запрос на замену) Перед заменой IDE запросит подтверждение.

Если диалоговое окно закрывается с помощью кнопки "ОК" , будет заменено только следующее вхождение поискового текста. Если диалоговое окно закрывается с помощью кнопки "Change All"(Заменить все), будут заменены все вхождения поискового текста.


### 6.7 Обозреватель символов.

Обозреватель символов позволяет искать все вхождения символа. Символ может быть переменной, типом, процедурой или константой, встречающейся в программе или источниках.

Чтобы включить браузер символов, программа или модуль должны быть скомпилированы с информацией браузера. Это можно сделать, установив параметры информации о браузере в диалоговом окне параметров компилятора.

Среда IDE позволяет просматривать несколько типов символов:
- `Procedures`(Процедуры) Позволяет быстро перейти к определению или реализации процедуры.
- `Objects`(Объекты) Быстрый поиск объекта.
- `Modules`(Модули) Просмотр модуля.
- `Globals`(Глобально) Просмотр любого глобального символа.
- `Arbitrary`(Произвольный символ) Просмотр произвольного символа.

Во всех случаях сначала должен быть выбран символ для просмотра. После этого появится окно просмотра. В окне просмотра отображаются все места, где встречался символ. Выбор местоположения и нажатие клавиши пробела приведет к тому, что редактор перейдет к этому месту; строка, содержащая символ, будет выделена.

Если местоположение находится в исходном файле, который еще не отображается, откроется новое окно с загруженным исходным файлом.

После того, как желаемое местоположение было достигнуто, окно браузера можно закрыть обычными командами.

Поведение браузера можно настроить с помощью диалогового окна параметров браузера, используя меню `Options—Browser`(Параметры—Браузер). Диалог настроек браузера выглядит как рисунок (6.9).

| Рисунок 6.9 Диалоговое окно настроек обозревателя |
| :-----------------------------------------------: |
|     ![](pictures/fig_6_9_browser_opt_dlg.png)     |

Следующие параметры могут быть установлены в диалоговом окне параметров браузера:

- `Symbols`(Символы) Здесь можно выбрать типы символов, отображаемых в браузере:
    - `Labels`(Метки) Показываются метки.
    - `Constants`(Константы) Показываются константы.
    - `Types`(Типы) Показываются типы.
    - `Variables`(Переменные) Показываются переменные.
    - `Procedures`(Процедуры) Показываются процедуры.
    - `Inherited`(Унаследованный)
- `Sub-browsing`(Дополнительный просмотр) Определяет, что должен делать браузер при отображении элементов сложного символа, такого как запись или класс:
    - `New browser`(Новый браузер) Члены отображаются в новом окне браузера.
    - `Replace current`(Заменить текущий) Содержимое текущего окна заменяется элементами выбранного сложного символа.
- `Preferred pane`(Предпочтительная панель) Указывает, какая панель отображается в браузере при ее первом открытии:
    - `Scope`(Объем)
    - `Reference`(Ссылка)
- `Display`(Отображение) Определяет, как браузер должен отображать символы:
    - `Qualified symbols`(Подходящие символы)
    - `Sort always`(Сортировать всегда) Сортирует символы в окне браузера.


### 6.8 Запуск программ.
Скомпилированная программа может быть запущена прямо из IDE. Это можно сделать одним из нескольких способов:

1. выбрать меню `Run—Run`(Выполнить - Запустить) или
2. нажать `<Ctrl-F9>`.

Если параметры командной строки должны быть переданы в программу, они могут быть заданы через меню `Run—Parameters`(Выполнить - Опции). Окно диалога параметров программы выглядит как рисунок (6.10).

| Рисунок 6.10 Окно диалога параметров программы  |
| :---------------------------------------------: |
| ![](pictures/fig_6_10_run_param_window_dlg.png) |

После запуска программы она продолжит работать до тех пор, пока:

1. программа не завершится нормально,
2. не произойдет ошибка,
3. не встретится точка останова, или
4. программа не будет прервана пользователем.

Последний вариант возможен, только если программа скомпилирована с отладочной информацией.

В качестве альтернативы, можно расположить курсор где-нибудь в исходном файле и запускать программу до тех пор, пока выполнение не достигнет строки исходника, где расположен курсор. Это может быть сделано, если:

1. выбрать меню `Run — Goto Cursor` (Запуск - Перейти к курсору),
2. нажать `<F4>`.

Опять же, это возможно, только если программа была скомпилирована с отладочной информацией.
Программа также может выполняться построчно. Нажатие `<F8>` выполнит следующую строку программы. Если программа еще не запущена, она будет запущена. Повторное нажатие клавиши `<F8>` будет запускать программу построчно, а в среде IDE будет отображаться строка, которая будет выполнена в окне редактора. Если где-то в коде происходит вызов подпрограммы, то нажатие клавиши `<F8>` приведет к выполнению всей подпрограммы, прежде чем управление вернется в IDE. Если код подпрограммы также должен быть пропущен, тогда вместо него следует использовать `<F7>`. Использование `<F7>` приведет к тому, что IDE будет выполнять построчно любую встречаемую подпрограмму.
Если подпрограмма выполняется пошагово, то меню `Run—Until return`(Выполнить - до возврата) будет запускать программу до конца текущей подпрограммы.
Если программа должна быть остановлена до того, как она закончит свою работу сама, это можно сделать посредством:

1. выбора в меню `Run—Program reset`(Выполнить - сброс программы), или
2. нажатия `<Ctrl-F2>`.

Запущенная программа будет прервана.



### 6.9 Отладка программ.

Чтобы отладить программу, она должна быть скомпилирована с отладочной информацией. Компиляция программы с отладочной информацией позволяет:

1. Выполнять программу построчно.
2. Запускать программу до определенной точки (точки останова).
3. Проверять содержимое переменных или областей памяти во время работы программы.

#### 6.9.1 Использование точек останова.

Точки останова приведут к остановке работающей программы, когда выполнение достигнет строки, где была установлена точка останова. В этот момент управление возвращается в IDE, и можно продолжить выполнение.
Чтобы установить точку останова на текущей строке источника, используйте пункт меню `Debug—Breakpoint`(Отладка - точка останова) или нажмите `<Ctrl-F8>`.
Список текущих точек останова можно получить через меню `Debug—Breakpoint list`(Отладка - Список точек останова). Окно списка точек останова показано на рисунке (6.11).

| Рисунок 6.11 Окна списка точек останова |
| :-------------------------------------: |
| ![](pictures/fig_6_11_bp_list_wnd.png)  |

В окне списка точек останова можно выполнить следующие действия:

- `New`(Новый) Показывает диалоговое окно свойств точки останова, где можно ввести свойства для новой точки останова.
- `Edit`(Редактировать) Отображает диалоговое окно свойств точки останова, в котором можно изменить свойства выделенной точки останова.
- `Delete`(Удалить) Удаляет выделенную точку останова.

Диалог можно закрыть кнопкой `Close`(Закрыть). Диалог свойств точки останова показан на рисунке (6.12)

| Рисунок 6.12 Диалоговое окно свойств точек останова |
| :-------------------------------------------------: |
|       ![](pictures/fig_6_12_bp_prop_dlg.png)        |



#### 6.9.2 Использование механизма слежения.

Когда отладочная информация компилируется в программе, можно использовать механизм слежения. Механизм слежения - это выражения, которые могут быть оценены средой IDE и показаны в отдельном окне. Когда выполнение программы останавливается (например, в точке останова), все отслеживаемые выражения будут оценены с показом их текущего значения.
Установка новых объектов слежения может быть выполнена с помощью команды меню `Debug — Add watch`(Отладка - Добавить слежение) или нажатием `<Ctrl-F7>`. Когда это будет сделано, появится диалоговое окно свойств объектов слежения и можно будет ввести новое выражение. Диалог свойств часов показан на рисунке (6.13).

| Рисунок 6.13 Диалоговое окно свойств объектов слежения |
| :----------------------------------------------------: |
|       ![](pictures/fig_6_13_watch_prop_dlg.png)        |

В диалоговом окне можно ввести выражение. Показываются любые возможное предыдущее и текущее значения.
**Примечание**: поскольку в среде IDE для отладки используется GDB, на FreeBSD необходимо вводить все выражения в ВЕРХНЕМ РЕГИСТРЕ.
Список объектов слежения и их текущие значения доступны в окне слежения, которое можно открыть с помощью меню `Debug—Watches`(Отладка - Отслеживание). Окно списка объектов слежения показано на рисунке (6.14).

|          Рисунок 6.14 Окно списка объектов слежения          |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_14_watch_list_wnd.png" style="zoom:80%;" /> |


Нажатие `Enter` или пробела покажет диалог свойств объектов слежения для текущих выделенных объектов слежения в окне слежения.
Список объектов слежения обновляется всякий раз, когда среда IDE возобновляет управление при отладке программы.


#### 6.9.3 Стек вызовов.

Стек вызовов помогает в отображении потока программы. Он показывает список процедур, которые вызываются в данный момент, в обратном порядке. Окно стека вызовов можно отобразить с помощью меню `Debug — Call Stack`(Отладка - Стек вызовов). Оно покажет адрес или имя процедуры всех активных в настоящее время процедур с их именами и адресами. Если были переданы параметры, они также будут показаны. Стек вызовов показан на рисунке (6.15).

|               Рисунок 6.15 Окно стека вызовов                |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_15_call_stack_wnd.png" style="zoom:80%;" /> |

При нажатии клавиши пробела в окне стека вызовов строка, соответствующая вызову, будет выделена в окне редактирования.


#### 6.9.4 Окно GDB.

Окно GDB обеспечивает прямое взаимодействие с отладчиком GDB. В нем команды GDB можно вводить так же, как в GDB. Ответ GDB будет показан в окне.
Дополнительную информацию об использовании GDB можно найти в разделе [10.2](###10.2-Использование-gdb-для-отладки-вашей-программы.), но окончательная ссылка, конечно же, на само [руководство по GDB](https://www.gnu.org/software/gdb/documentation). Окно GDB показано на рисунке (6.16).

|                    Рисунок 6.16 Окно GBD                     |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_16_gdb_wnd.png" style="zoom:80%;" /> |



### 6.10 Использование инструментов.

Меню `Tools`(Инструменты) обеспечивает легкий доступ к внешним инструментам. В нем также есть три предопределенных инструмента для программистов: таблица ASCII, инструмент grep и калькулятор. Вывод внешних инструментов также доступен через это меню.

#### 6.10.1 Окно сообщений.

Вывод внешних утилит перенаправляется IDE и будет отображаться в окне сообщений. Окно сообщений отображается автоматически, если был запущен внешний инструмент. Окно сообщений также можно отобразить вручную, выбрав пункт меню `Tools—Messages`(Инструменты - Сообщения) или нажав клавишу `<F11>`. Окно сообщений показано на рисунке (6.17).

|    Рисунок 6.17 Окно сообщений     |
| :--------------------------------: |
| ![](pictures/fig_6_17_msg_wnd.png) |

Если выходные данные инструмента содержат имена файлов и номера строк, окно сообщений можно использовать для навигации по источнику, как в окне просмотра:

1. Нажатие Enter или двойной щелчок на строке вывода приведет к переходу к указанной строке источника и закроет окно сообщений.
2. Нажатие клавиши пробела приведет к переходу к указанной исходной строке, но оставит окно сообщений открытым, с фокусом на нем. Это позволяет быстро выбрать другую строку сообщения с помощью клавиш со стрелками и перейти в другое место в источниках.

Алгоритм, который извлекает имена файлов и номера строк из выходных данных инструмента, довольно сложен, но в некоторых случаях он может дать сбой (предложения по улучшению или, что еще лучше, патчи, улучшающие алгоритм, всегда приветствуются).

#### 6.10.2 Grep.

Один внешний инструмент в меню `Tools`(Инструменты) уже предопределен: пункт меню для вызова утилиты `grep` (`Tools—Grep`(Инструменты - Grep) или `<Shift-F2>`). `Grep` ищет данную строку в файлах и возвращает строки, содержащие эту строку. Строка поиска может быть даже регулярным выражением. Для работы этого пункта меню должна быть установлена программа [`grep`](https://www.gnu.org/software/grep), поскольку она не распространяется с Free Pascal. 

Окно сообщений, показанное на рисунке (6.17) в предыдущем разделе, показывает вывод типичного сеанса `grep`. Окно сообщений может использоваться в сочетании с `grep` для поиска особых случаев в тексте.

`Grep` поддерживает регулярные выражения. Регулярное выражение - это строка со специальными символами, которые описывают целый класс выражений. Командная строка в dos или linux имеет ограниченную поддержку регулярных выражений: ввод `ls *.pas` (или `dir *.pas`) для получения списка всех файлов Pascal в каталоге. `*.pas` - это нечто похожее на регулярное выражение. Он использует подстановочный знак для описания целого класса строк: тех, которые заканчиваются на «.pas». Регулярные выражения предлагают гораздо больше: например, `[A-Z] [0-9] +` описывает все строки, которые начинаются с заглавной буквы, за которой следуют одна или несколько цифр.

В сферу действия данного руководства не входит подробное описание регулярных выражений. Пользователи системы linux могут получить больше информации о `grep`, используя `man grep` в командной строке.



#### 6.10.3 Таблица ASCII.

Меню инструментов также предоставляет таблицу ASCII (`Tools — ASCII table`(Инструменты - таблица ASCII). Таблицу ASCII можно использовать для поиска кодов ASCII, а также для вставки символов в окно, которое было активным при вызове таблицы.

Чтобы открыть ASCII-код символа в таблице, наведите курсор на этот символ или щелкните его мышью. Десятичные и шестнадцатеричные значения символа показаны внизу в окне таблицы ASCII.

Чтобы вставить символ в окно редактора:

1. с использованием мыши, дважды щелкните ей по символу, или,
2. с использованием клавиатуры, нажмите `<Enter>`, когда на символе находится курсор.

Это особенно полезно для вставки графических символов в константу.

Таблица ASCII остается активной, пока другое окно не будет явно активировано; таким образом, несколько символов могут быть вставлены одновременно. Таблица ASCII показана на рисунке (6.18).

|             Рисунок 6.18 Таблица символов ASCII              |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_18_ascii_table.png" style="zoom:80%;" /> |



#### 6.10.4 Калькулятор.

Калькулятор позволяет проводить быстрые вычисления, не покидая IDE. Это простой калькулятор, поскольку он не заботится о приоритетах операторов, а брекетинг операций (пока) не поддерживается.

Результат вычислений можно вставить в текст с помощью нажатия клавиши `<Ctrl-Enter>`. Диалог калькулятора показан на рисунке (6.19).

|          Рисунок 6.19 Диалоговое окно калькулятора           |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_19_calc_dlg.png" style="zoom:80%;" /> |

Калькулятор поддерживает все основные математические операции, такие как сложение, вычитание, деление и умножение. Они сведены в таблицу (6.1).

**Таблица 6.1 Основные математические операции**

| Операция                             | Кнопка |    Клавиша    |
| ------------------------------------ | :----: | :-----------: |
| Сложение двух чисел                  |   +    |     `<+>`     |
| Вычитание двух чисел                 |   -    |     `<->`     |
| Умножение двух чисел                 |   *    |     `<*>`     |
| Деление двух чисел                   |   /    |     `</>`     |
| Удаление последнего введенного числа |  <--   | `<Backspace>` |
| Очистить дисплей                     |   С    |     `<С>`     |
| Изменение знака                      |   +    |               |
| Вычисление процента                  |   %    |     `<%>`     |
| Получение результата операции        |   =    |   `<Enter>`   |



Но также поддерживаются более сложные математические операции, такие как возведение в степень и логарифмы. Расширенные математические операции показаны в таблице (6.2).

**Таблица 6.2 Расширенные математические операции**

| Операция                          | Кнопка | Клавиша |
| --------------------------------- | :----: | :-----: |
| Возведение в степень              |  x^y   |         |
| Вычисление обратного значения     |  1/x   |         |
| Вычисление квадратного корня      |  sqr   |         |
| Вычисление натурального логарифма |  log   |         |
| Возведение в квадрат              |  x^2   |         |



Как и многие калькуляторы, калькулятор в IDE также поддерживает сохранение одного значения в памяти, и с этим значением памяти можно выполнить несколько операций. Доступные операции перечислены в таблице (6.3).

**Таблица 6.3 Расширенные команды калькулятора**

| Операция                                  | Кнопка | Клавиша |
| ----------------------------------------- | :----: | :-----: |
| Добавление отображаемого числа в память   |   М+   |         |
| Вычитание отображаемого числа из памяти   |   М-   |         |
| Перемещение содержимого памяти на дисплей |  М-->  |         |
| Перемещение содержимого дисплея в память  |  M<--  |         |
| Возведение в квадрат                      |  x^2   |         |
| Обмен содержимым между памятью и дисплеем | M<-->  |         |



#### 6.10.5 Добавление новых инструментов.

Меню инструментов может быть расширено любой внешней программой, ориентированной на командную строку. Вывод такой программы будет перехвачен и отображен в окне сообщений.

Добавление инструмента в меню инструментов можно выполнить с помощью меню `Options—Tools`(Параметры - Инструменты). Это покажет диалог инструментов. Диалог инструментов показан на рисунке (6.20).

| Рисунок 6.20 Диалоговое окно настроек инструментов |
| :------------------------------------------------: |
|     ![](pictures/fig_6_20_tools_cong_dlg.png)      |


В диалоговом окне инструментов доступны следующие действия:
- `New`(Новый) Показывает диалоговое окно свойств инструмента, в котором можно ввести свойства нового инструмента.
- `Edit`(Редактировать) Отображение диалогового окна свойств инструмента, в котором можно редактировать свойства выделенного инструмента.
- `Delete`(Удалить) Удаляет выделенный в данный момент инструмент.
- `Cancel`(Отмена) Отменяет все изменения и закрывает диалог.
- `OK` Сохраняет все изменения и закрывает диалог.

Определения инструментов записывабются в файл конфигурации рабочего стола. Таким образом, если не включено автоматическое сохранение файла рабочего стола, файл рабочего стола следует сохранять явно после закрытия диалогового окна.




#### 6.10.6 Мета-параметры.

При указании командной строки для вызываемого инструмента можно использовать мета-параметры. Мета-параметры являются переменными и заменяются их содержимым перед передачей командной строки в инструмент.
- `$CAP` Записывает выходные данные инструмента.
- `$CAP_MSG()` Захватывает вывод инструмента и помещает его в окно сообщений.
- `$CAP_EDIT()` Захватывает выходные данные инструмента и помещает его в отдельное окно редактора.
- `$COL` Заменяется на столбец курсора в активном окне редактора. Если активного окна нет или активное окно является диалоговым окном, оно заменяется на 0.
- `$CONFIG` Заменяется полным именем файла текущей конфигурации.
- `$DIR()` Заменяется полным каталогом аргумента имени файла, включая конечный разделитель каталогов, например 
```bash
$DIR('d:\data\myfile.pas')
```
вернет `d:\data\`.
- `$DRIVE()` Заменяется буквой диска аргумента имени файла, например 
```bash
$DRIVE('d:\data\myfile.pas')
```
вернет `d:`.
- `$EDNAME` Заменяется на полное имя файла в активном окне редактирования. Если нет активного окна редактирования, это пустая строка.
- `$EXENAME` Заменяется на исполняемое имя, которое будет создано, если будет использована команда make. (т. е. из настройки «Основной файл» или активного окна редактирования).
- `$EXT()` Заменяется расширением аргумента имени файла. Расширение включает в себя точку, например
```bash
$EXT('d:\data\myfile.pas') 
```
вернет `.pas`.
- `$LINE` Заменяется на номер строки курсора в активном окне редактирования. Если окно редактирования отсутствует или активно, это 0.
- `$NAME()` Заменяется частью имени (исключая расширение и точку) аргумента имени файла, например

```bash
$NAME('d:\data\myfile.pas') 
```
вернет `myfile`.
- `$NAMEEXT()` Заменяется на часть имени и расширения аргумента имени файла, например

```bash
$NAMEEXT('d:\data\myfile.pas')
```
вернет `myfile.pas`.
- `$NOSWAP` ничего не делает в IDE; это предусмотрено только для совместимости с Turbo Pascal.
- `$PROMPT()` отображает диалоговое окно, которое позволяет редактировать все аргументы, которые идут после него. Аргументы, которые появляются перед ключевым словом `$PROMPT`, не доступны для редактирования. `$PROMPT()` также может принимать необязательный аргумент имени файла. Если fhuevtyn присутствует, `$PROMPT()` загрузит описание диалога из аргумента имени файла. Например. 
```bash
$PROMPT(cvsco.tdf) 
```
проанализирует файл `cvsco.tdf`, создаст с ним диалог и отобразит его. После закрытия диалога информация, введенная пользователем, используется для построения командной строки инструмента. См. раздел [6.10.7](####6.10.7-Создание-диалогового-окна-командной-строки.) для получения дополнительной информации о том, как создать описание диалога.
- `$SAVE` Перед выполнением команды активное окно редактора сохраняется, даже если оно не было изменено.
- `$SAVE_ALL` Перед выполнением команды все несохраненные файлы редактора сохраняются без запроса.
- `$SAVE_CUR` Перед выполнением команды содержимое активного окна редактора сохраняется без запроса изменения.
- `$SAVE_PROMPT` Перед выполнением команды отображается диалоговое окно с вопросом, следует ли сохранять несохраненные файлы перед выполнением команды.
- `$WRITEMSG()` Записывает выходные данные проанализированного инструмента в файл с именем, указанным в аргументе.



#### 6.10.7 Создание диалогового окна командной строки.

При определении инструмента, можно показать диалоговое окно пользователю, запрашивая дополнительные аргументы, используя макрос-команду `$PROMPT(filename)`. Дистрибутив Free Pascal содержит несколько готовых диалогов, таких как `grep`, `cvs checkout` и `cvs check in`. Файлы для этих диалогов находятся в двоичном каталоге и имеют расширение `.tdf`.

В этом разделе объясняется формат файла для файла описания диалога. Формат этого файла напоминает `.INI`-файл Windows, где каждый раздел в файле описывает элемент (или элемент управления) в диалоговом окне. Кнопка «ОК» и «Отмена» добавляются в конец диалогового окна автоматически, поэтому их не следует указывать в определении диалога.

Раздел `Main` - специальный раздел. Он описывает, как результат диалога будет передан в командную строку, и общий размер диалога.

**Примечание**. Ключевые слова, содержащие строковое значение, должны обрамлять строковое значение двойными кавычками, навроде
```pascal
Title = "Dialog title"
```
Раздел `Main` должен содержать следующие ключевые слова:
- `Title` Заголовок диалога. Он появится в заголовке окна диалога. Строка должна быть заключена в кавычки.
- `Size` Размер диалога, он имеет формат `(Cols,Rows)`, поэтому `Size=(59,9)` означает, что диалог имеет ширину 59 символов и высоту 9 строк. Этот размер не включает границу диалога.
- `CommandLine` указывает, как командная строка будет передана программе, на основе записей, сделанных в диалоговом окне. Текст, введенный здесь, будет передан после замены некоторых метапеременных их значениями. Элемент метапеременной - это имя некоторого элемента управления в диалоговом окне, заключенное в символы процента (`%`). Имя элемента управления будет заменено текстом, связанным с элементом управления. Рассмотрим следующий пример: 
```bash
CommandLine = "- n% l%% v%% i%% w%% searchstr%% filemask%" 
```
Здесь значения, связанные с элементами управления с именами `l`, `v`, `i`, `w` и `searchstr` и `filemask`, будут вставляется в строку командной строки.
- `Default` Имя элемента управления, который является элементом управления по умолчанию, то есть элементом управления, который должен иметь фокус при открытии диалога.

Ниже приведен пример корректного раздела `Main`:
```ini
[Main]  
Title="GNU Grep"  
Size=(56,9)  
CommandLine="-n %l% %v% %i% %w% %searchstr% %filemask%"  
Default="searchstr"
```
После раздела `Main` должен быть указан раздел для каждого элемента управления, который должен отображаться в диалоговом окне. Каждый раздел имеет имя элемента управления, который он описывает, как в следующем примере:
```ini
[CaseSensitive]  
Type=CheckBox  
Name="~C~ase sensitive"  
Origin=(2,6)  
Size=(25,1)  
Default=On  
On="-i"
```
Каждый раздел элемента управления должен иметь как минимум следующие ключевые слова, связанные с ним:
- `Type` Тип элемента управления. Возможные значения:
    - `Label` Простая текстовая метка, которая будет отображаться в диалоговом окне. Элемент управления может быть связан с этим ярлыком, поэтому он будет сфокусирован, когда пользователь нажимает подсвеченную букву в заголовке ярлыка (если есть).
    - `InputLine` Поле редактирования, в которое можно ввести текст.
    - `CheckBox` Флажок, который может быть включен или выключен.

- `Origin` Указывает, где элемент управления должен находиться в диалоговом окне. Начало координат указано как (слева, сверху), а верхний левый угол диалогового окна имеет координаты (1,1) (не считая фрейма).
- `Size` Указывает размер элемента управления, который должен быть указан как (Cols, Rows).
С каждым элементом управления связаны определенные ключевые слова; они будут описаны ниже.
С меткой (`Type=Label`) связаны следующие дополнительные ключевые слова:
    - `Text` Текст, отображаемый в метке. Если одна из букв должна быть выделена, чтобы ее можно было использовать в качестве ярлыка, она должна быть заключена в символы тильды (`˜`). Например, в 
```ini
Text="~T~ext to find"
```
`T` будет подсвечен.
    - `Link` Имя элемента управления в диалоговом окне, которое может быть указано. Если указано, нажатие на выделенную букву метки в сочетании с клавишей `<Alt>` приведет к фокусированию на указанном здесь элементе управления.

Метка не вносит вклад в текст командной строки; она предназначена только для информационных и навигационных целей. Ниже приведен пример раздела описания метки:
```ini
[label2]  
Type=Label  
Origin=(2,3)  
Size=(22,1)  
Text="File ~m~ask"  
Link="filemask"
```

Элемент редактирования (`Type=InputLine`) позволяет вводить произвольный текст. Текст элемента управления для редактирования будет вставлен в командную строку, если на него есть ссылка. В разделе управления строкой ввода можно указать следующее ключевое слово:
    - `Value` Можно указать стандартное значение (текст) для элемента управления редактированием. Это значение будет заполнено, когда появится диалоговое окно.

Ниже приведен пример раздела строки ввода:
```ini
[filemask]  
Type=InputLine  
Origin=(2,4)  
Size=(22,1)  
Value="*.pas *.pp *.inc"
```

Элемент управления checkbox (`Type=CheckBox`) представляет флажок, который может находиться в одном из двух состояний: включен или выключен. С каждым из этих состояний может быть связано значение, которое будет передано в командную строку. В разделе типа флажка могут отображаться следующие ключевые слова:
    - `Name` Текст, который появляется после флажка. Если в нем есть выделенная буква, эта буква может быть использована для установки или снятия флажка с использованием комбинации `<Alt>-`буква`.
    - `Default` Указывает, установлен ли флажок или нет при появлении диалогового окна (значение включено или выключено).
    - `On` Текст, связанный с этим флажком, если он находится в отмеченном состоянии.
    - `Off` Текст, связанный с этим флажком, если он находится в непомеченном состоянии.

Ниже приведен пример правильного описания флажка:
```ini
[i]  
Type=CheckBox  
Name="~C~ase sensitive"  
Origin=(2,6)  
Size=(25,1)  
Default=On  
On="-i"
```
Если флажок помечен, то значение `-i` будет добавлено в командную строку инструмента. Если он не помечен, никакое значение не будет добавлено.




### 6.11 Управление проектами и опции компилятора.

Управление проектами в Pascal намного проще, чем в C. Компилятор знает из исходника, какие модули, исходники и т.д. ему нужны. Таким образом, Free Pascal IDE не требуется полнофункциональный менеджер проектов, как предлагают некоторые среды разработки на Си. Тем не менее в IDE есть некоторые настройки, которые применяются к проектам.


#### 6.11.1 Основной файл.

Без первичного файла IDE компилирует/запускает исходник активного окна при запуске программы. Если указан первичный файл, IDE всегда компилирует/запускает этот исходник, даже если другое окно исходника активно. С помощью пункта меню `Compile—Primary file...`(Компиляция — Основной файл ...) можно открыть диалоговое окно файла, в котором можно выбрать основной файл. Только пункт меню `Compile—Compile`(Компиляция - Компилировать) компилирует активное окно независимо от выбора первичного файла. Это полезно, если редактируется большой проект, и нужно проверять только синтаксис текущего исходника.

Пункт меню `Compiler—Clear primary file`(Компилятор - Очистить основной файл) восстанавливает поведение IDE по умолчанию, то есть команды *compile* и *run* применяются к активному окну.


#### 6.11.2 Диалог каталога.

В диалоговом окне каталогов можно указать каталоги, в которых компилятор должен искать модули, библиотеки, объектные файлы. Там также указано, где должны храниться выходные файлы. Можно ввести несколько каталогов (кроме выходного), разделенных точкой с запятой. Диалог каталогов показан на рисунке (6.21).

|     Рисунок 6.21 Диалоговое окно конфигурации каталогов      |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_21_dir_conf_dlg.png" style="zoom:120%;" /> |



Можно указать следующие каталоги:
- `EXE & PPU directories` Указывает, куда будут идти скомпилированные модули и исполняемые файлы. (ключ `-FE` в командной строке (см. раздел [5.1.3](####5.1.3-Опции,-касающиеся-файлов-и-каталогов.)))
- `Object directories` Указывает, где компилятор ищет внешние объектные файлы. (`-Fo` в командной строке (см. раздел [5.1.3](####5.1.3-Опции,-касающиеся-файлов-и-каталогов.)))
- `Library directories` Указывает, где компилятор (точнее, компоновщик) ищет внешние библиотеки. (`-Fl` в командной строке(см. раздел [5.1.3](####5.1.3-Опции,-касающиеся-файлов-и-каталогов.)))
- `Include directories` Указывает, где компилятор будет искать включаемые файлы, включенные в директиву `{$i}` (`-Fi` или `-I` в командной строке (см. раздел [5.1.3](####5.1.3-Опции,-касающиеся-файлов-и-каталогов.)))
- `Unit directories` Указывает, где компилятор будет искать скомпилированные модули. Компилятор всегда смотрит первым в текущем каталоге, а также в некоторых стандартных каталогах. (`-Fu` в командной строке (см. раздел [5.1.3](####5.1.3-Опции,-касающиеся-файлов-и-каталогов.)))


#### 6.11.3 Целевая операционная система.

Пункт меню «Скомпилировать - Target» позволяет указать целевую операционную систему, для которой будут скомпилированы исходные коды. Изменение цели не влияет на переключатели или каталоги компилятора. Это влияет на некоторые определения, заданные компилятором. Настройки здесь соответствуют опции в командной строке `-T` (см. раздел [5.1.4](####5.1.4-Опции,-контролирующие-вид-вывода.)). Пример диалогового окна цели компиляции показан на рисунке (6.22): на самом деле диалоговое окно будет отображать только те цели, которые фактически поддерживает IDE.

|         Рисунок 6.22 Диалоговое окно цели компиляции         |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_22_compil_tgt_dlg.png" style="zoom:70%;" /> |


Можно установить следующие цели (список зависит от платформы, для которой была скомпилирована среда):
- `Dos (go32v1)` Этот переключатель со временем исчезнет, так как эта цель больше не поддерживается.
- `Dos (go32v2)` Компиляция под DOS, используя версию 2 расширителя Go32.
- `FreeBSD` Компиляция под FreeBSD.
- `Linux` Компиляция под Linux.
- `OS/2` Компиляция под OS/2 (с использованием расширителя EMX).
- `Windows` Компиляция под Windows.

Текущая выбранная целевая операционная система отображается в пункте меню `Target`(Цель) в меню `Compile`(Компиляция). Первоначально будет установлена цель той операционной системы, для которой была скомпилирована среда.


#### 6.11.4 Опции компилятора.

Меню `Options—Compiler`(Параметры - Компилятор) позволяет настроить параметры, которые влияют на поведение компиляторов. При выборе этого пункта меню появляется диалоговое окно с несколькими вкладками. Есть шесть вкладок:
- `Syntax` Здесь можно установить параметры, которые влияют на различные синтаксические аспекты кода. Они в основном соответствуют опции `-S` в командной строке (раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).)).
- `Code generation` Эти параметры управляют сгенерированным кодом; они в основном касаются параметров командной строки `-C` и `-X`.
- `Verbose` Она устанавливает "многословность" компилятора при компиляции. Сообщения компилятора отображаются в окне сообщений компилятора (можно вызвать с помощью `<F12>`).
- `Browser` Опции, касающиеся генерируемой браузером информации. Информация браузера должна быть сгенерирована для работы браузера символов.
- `Assembler` Параметры, касающиеся чтения ассемблерных блоков (`-R` в командной строке) и сгенерированного ассемблером кода (`-A` в командной строке)
- `Processor` Здесь можно выбрать целевой процессор.

На каждой вкладке есть два поля ввода: первое для задания условий и второе для дополнительных аргументов компилятора. Символы и аргументы должны быть разделены точками с запятой.
Вкладка синтаксиса в диалоговом окне параметров компилятора показана на рисунке (6.23).

|   Рисунок 6.23 Вкладка настроек синтаксиса    |
| :-------------------------------------------: |
| ![](pictures/fig_6_23_syntax_options_tab.png) |

В диалоговом окне параметров синтаксиса можно установить следующие параметры:

- `Stop after first error` Если помечено, компилятор останавливается после первой ошибки. Обычно компилятор продолжает компиляцию до фатальной ошибки. (`-Se` в командной строке (см. раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).)))
- `Allow label and goto` Разрешает использование объявлений меток и операторов goto (`-Sg` в командной строке (см. раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).))).
- `Enable macros` Разрешает использование макросов (`-Sm` в командной строке  (см. раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).))).
- `Allow inline` Разрешает использование встроенных функций (`-Sc` в командной строке (см. раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).))).
- `Include assertion code` Включает операторы `Assert` в код.
- `Load kylix compat. unit` Загружает модуль совместимости Kylix.
- `Allow STATIC in objects` Разрешает модификатор `Static` для методов объекта (`-St` в командной строке (см. раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).)))
- `C-like operators` Позволяет использовать некоторые расширенные операторы, такие как `+=`, `-=` и т.д. (`-Sc` в командной строке (см. раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).))).
- `Compiler mode` выбирает подходящий режим компилятора:
    - `Free Pascal Dialect` Стандартный режим компилятора Free Pascal (FPC).
    - `Object pascal extensions on` Включает использование классов и исключений (`-Sd` в командной строке (см. раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).))).
    - `Turbo pascal compatible` Пробует быть более совместимым с Turbo Pascal (`-So` в командной строке (см. раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).))).
    - `Delphi compatible` Пробует быть более совместимыми с Delphi (`-Sd` в командной строке (см. раздел [5.1.5](####5.1.5-Опции,-касающиеся-исходников-(языковые опции).))).
    - `Macintosh Pascal dialect` Пробует быть совместимым с Macintosh Pascal.

Вкладка генерации кода в диалоге параметров компилятора показана на рисунке (6.24).

|   Рисунок 6.24 Вкладка настроек генерации кода   |
| :----------------------------------------------: |
| ![](pictures/fig_6_24_code_gener_option_tab.png) |

В диалоговом окне генерации кода можно установить следующие параметры:
- `Run-time checks` Управляет тем, какой код проверки во время выполнения генерируется. Если такая проверка не удалась, генерируется ошибка во время выполнения. Может быть сгенерирован следующий код проверки :
    - `Range checking`(Проверка диапазона) Проверяет результаты операций перечисления и подмножества (опция командной строки `-Cr` (см. раздел [5.1.4](####5.1.4-Опции,-контролирующие-вид-вывода.))).
    - `Stack checking`(Проверка стека) Проверяет, не достигнут ли предел стека (опция командной строки `-Cs` (см. раздел [5.1.4](####5.1.4-Опции,-контролирующие-вид-вывода.))).
    `I/O checking`(Проверка ввода-вывода) Проверяет результат операций ввода-вывода (опция командной строки `-Ci` (см. раздел [5.1.4](####5.1.4-Опции,-контролирующие-вид-вывода.))).
    - `Integer overflow checking`(Проверка целочисленного переполнения) Проверяет результат целочисленных операций (параметр командной строки `-Co` (см. раздел [5.1.4](####5.1.4-Опции,-контролирующие-вид-вывода.))).
    - `Object method call checking`(Проверка вызова метода объекта) Проверяет корректность указателя метода перед его вызовом.
    - `Position independent code`(Независимый от позиции код) Генерирует PIC-код (Position-independent code).
    - `Create smartlinkable units` Создание смарт-связываемых блоков.

- `Optimizations` Какую оптимизацию следует использовать при компиляции:
    - `Generate faster code`(Генерировать быстрейший код) Соответствует параметру командной строки `-OG`.
    - `Generate smaller code`(Генерировать меньший код) Соответствует параметру командной строки `-Og`.

Более подробную информацию об этих переключателях можно найти в разделе [5.1.4](####5.1.4-Опции,-контролирующие-вид-вывода.).
Вкладка процессора диалогового окна параметров компилятора показана на рисунке (6.25).
В диалоговом окне процессора можно указать целевой процессор. Компилятор может использовать разные оптимизации для разных процессоров.

|   Рисунок 6.25 Вкладка выбора процессора   |
| :----------------------------------------: |
| ![](pictures/fig_6_25_proc_select_tab.png) |

Подробная вкладка диалога параметров компилятора показана на рисунке (6.26).

|       Рисунок 6.26 Вкладка настроек вывода       |
| :----------------------------------------------: |
| ![](pictures/fig_6_26_vebrosity_options_tab.png) |

В этом диалоговом окне можно установить следующие параметры многословия (в командной строке: -v (см. раздел [5.1.2](#### 5.1.2 Варианты получения обратной связи.))):

- `Warnings` Генерирует предупреждения. Соответствует `-vw` в командной строке.
- `Notes` Создание заметок. Соответствует `-vn` в командной строке.
- `Hints` Генерация подсказок. Соответствует `-vh` в командной строке.
- `General info` Генерация общей информации. Соответствует `-vi` в командной строке.
- `Used tried info` Создание информации об используемых и проверенных файлах. Соответствует `-vut` в командной строке.
- `All` Включает полную детализацию. Соответствует `-va` в командной строке.
- `Show all procedures if error` Если возникает ошибка при использовании перегруженной процедуры, показываются все процедуры. Соответствует `-vb` в командной строке.

Вкладка браузера диалога параметров компилятора показана на рисунке (6.27).

|     Рисунок 6.27 Вкладка настроек браузера     |
| :--------------------------------------------: |
| ![](pictures/fig_6_27_browser_options_tab.png) |


В этом диалоговом окне можно настроить параметры браузера:

- `No browser`(по умолчанию) Компилятор не генерирует информацию о браузере.
- `Only global browser` Информация о браузере генерируется только для глобальных символов, то есть символов, определенных не в процедуре/функции (`-b` в командной строке)
- `Local and global browser` Информация о браузере генерируется для всех символов, то есть также для символов, которые определены в процедурах или функциях (`-bl` в командной строке)

**Примечание**. Если информация о браузере не создается, браузер символов в среде IDE не будет работать.

Вкладка ассемблера диалогового окна параметров компилятора показана на рисунке (6.28). Фактическое диалоговое окно может отличаться, поскольку оно зависит от целевого процессора, для которого была скомпилирована среда IDE.

|           Рисунок 6.28 Вкладка настроек ассемблера           |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_28_assembler_options_tab.png" style="zoom:110%;" /> |

В этом диалоговом окне могут быть установлены параметры чтения и записи на ассемблере:

- `Assembler reader` Позволяет установить стиль блоков ассемблера в исходном коде:
    - `AT&T assembler` Ассемблер пишется в стиле `AT&T`-ассемблера (`-Ratt` в командной строке).
    - `Intel style assembler`Ассемблер пишется в стиле Intel-ассемблера (`-Rintel` в командной строке).

**Примечание**: эта опция глобальная, но локально стиль ассемблера можно изменить с помощью директив компилятора.

- `Assembler info` При записи файлов на ассемблере эта опция решает, какая дополнительная информация записывается в файл на ассемблере в комментариях:
    - `List source` Исходные строки записываются в файлы ассемблера вместе с сгенерированным ассемблером (`-al` в командной строке).
    `List register allocation` Информация о внутреннем резервировании/освобождении регистров компилятора записывается в файл ассемблера (`-ar` в командной строке).
    - `List temp allocation` Резервирование/освобождение временного регистра записывается в файл ассемблера (`-at` в командной строке).
    - `List node allocation` Резервирование/освобождение узла записывается в файл ассемблера. (`-an` в командной строке).
    - `use pipe with assembler` Использует именованный канал в системах Unix при передаче кода ассемблера внешнему ассемблеру.

Последние три из этих опций в основном полезны для отладки самого компилятора, необходимость в их использовании редка.

- `Assembler output` Эта опция сообщает компилятору, какой вывод ассемблера должен быть сгенерирован.
    - `Use default output`(Использовать вывод по умолчанию) Это зависит от цели.
    - `Use GNU as` Сборка с использованием `gnu as` (`-Aas` в командной строке).
    - `Use NASM coff` Создается coff NASM-асемблер (go32v2, `-Anasmcoff` в командной строке)
    - `Use NASM elf` Создается NASM elf-ассемблер (linux, `-Anasmelf` в командной строке).
    - `Use NASM obj` Создается NASM obj-ассемблер (`-Anasmobj` в командной строке).
    - `Use MASM` Создается MASM-ассемблер (ассемблер Microsoft, `-Amasm` в командной строке).
    - `Use TASM` Создается TASM-ассемблер(Turbo Assembler, `-Atasm` в командной строке).
    - `Use coff` Записываются двоичные файлы coff напрямую, используя внутренний ассемблер (go32v2, `-Acoff` в командной строке).
    - `Use pecoff` Записываются двоичные файлы pecoff в файлы напрямую, используя встроенную программу записи (Win32).


#### 6.11.5 Параметры компоновщика.

Параметры компоновщика можно установить в меню `Options—Linker`(Параметры — Компоновщик». Это позволяет определить, как связываются библиотеки и модули, и как должен вызываться компоновщик. Диалоговое окно параметров компоновщика показано на рисунке (6.29).

|      Рисунок 6.29 Диалоговое окно настроек компоновщика      |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_29_linker_options_dlg.png" style="zoom:130%;" /> |

Могут быть установлены следующие параметры:

- `Call linker after` Если эта опция установлена, тогда пишется скрипт, который вызывает линкер. Это соответствует опции `-s` в командной строке (см. раздел [5.1.4](####5.1.4-Опции,-контролирующие-вид-вывода.)).
- `Only link to static library` Используются только статические библиотеки.
- `Preferred library type` С помощью этой опции можно установить тип библиотеки, с которой нужно осуществлять связывание:
    - `Target default`(Целевая по умолчанию) Это зависит от платформы.
    - `Dynamic libraries` Попытаться связать модули в динамических библиотеках (опция `-XD` в командной строке)
    - `Static libraries` Попытаться связать модули  в статических библиотеках (опция `-XS` в командной строке)
    - `Smart libraries` Попытаться связать модули в умно-связанных библиотеках (опция `-XX` в командной строке)


#### 6.11.6 Размеры памяти.

Диалог размеров памяти (доступный через `options—Memory sizes`(Опции — Размеры памяти) позволяет вводить размеры памяти для проекта. Диалоговое окно размеров памяти показан на рисунке (6.30).

|         Рисунок 6.30 Диалоговое окно размеров памяти         |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_30_mem_size_dlg.png" style="zoom:80%;" /> |

Можно задать следующие размеры:

- `Stack size` Устанавливает размер стека в байтах (опция `-Cs` в командной строке). Этот размер может игнорироваться в некоторых системах.
- `Heap size` Устанавливает размер кучи в байтах (опция `-Ch` в командной строке). Обратите внимание, что куча растет динамически настолько, насколько позволяет ОС.


#### 6.11.7 Параметры отладки.

В диалоговом окне параметров отладки (доступном через `Options—Debugger`(Параметры — Отладчик) можно задать некоторые параметры для включения отладочной информации в двоичный файл; в этом диалоговом окне также можно добавить дополнительные параметры компилятора. Диалог параметров отладки показан на рисунке (6.31).

|       Рисунок 6.31 Диалоговое окно настройки отладчика       |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_31_debug_opt_dlg.png" style="zoom:90%;" /> |


Могут быть установлены следующие параметры:

- `Debugging information` Сообщает компилятору, какую отладочную информацию следует компилировать. Можно выбрать один из следующих параметров:
    - `Strip all debug symbols from executable` Удалит всю отладочную и символьную информацию из двоичного файла. (опция `-Xs` в командной строке).
    - `Skip debug information generation` Исключит генерацию отладочной информации вообще.
    - `Generate debug symbol information` Включает отладочную информацию в двоичный файл (опция `-g` в командной строке). Обратите внимание, что никакая отладочная информация для модулей в библиотеке времени выполнения не будет включена, если не доступна версия RTL, скомпилированная с отладочной информацией. Отладочную информацию будут содержать модули, относящиеся только к текущему проекту.
    - `Generate also backtrace line information` Будет произведена компиляция с информацией об отладке и дополнительно в двоичный файл будет включен модуль `lineinfo`, так что в случае ошибки обратная трассировка будет содержать имена файлов и номера строк процедур в стеке вызовов (опция `-gl` в командной строке).
    - `Generate valgrind compatible debug info` Генерируется отладочная информация, которую можно прочитать с помощью valgrind (инструмент проверки памяти).
- `Profiling switches` Сообщает компилятору, должен ли код профиля включаться в двоичный файл.
    - `No profile information` Не имеет никакого эффекта, так как это задано по умолчанию.
    - `Generate Profile code for gprof` Если этот флажок установлен, код профилирования включается в двоичный файл (опция `-p` в командной строке).
- `Use another TTY for Debuggee` Будет предпринята попытка перенаправить вывод отлаживаемой программы в другое окно (терминал), имя файла которого следует ввести здесь.


#### 6.11.8 Режимы переключения.

Среда IDE позволяет сохранить набор настроек компилятора под общим именем. Он предоставляет 3 имени, под которыми могут быть сохранены ключи:

- `Normal` Для нормальной (быстрой) компиляции.
- `Debug` Для отладки, предназначен для установки большинства переключателей отладки. Также полезно для установки условного определения, например, разрешить включение некоторого кода отладки.
- `Release` Для компиляции финальной версии программы, двоичный файл должен быть очищен от отладочной информации, и должны быть использованы оптимизации.

Выбор одного из этих режимов загрузит параметры компилятора такими, какими они были сохранены в последний раз, когда выбранный режим был активен, то есть отдельные настройки не задаются и не сбрасываются.

При настройке и сохранении параметров компилятора сначала убедитесь, что вы выбрали правильный режим переключения; не имеет смысла устанавливать параметры отладки, пока активен переключатель `Release`. Диалог режима переключения показан на рисунке (6.32).

|      Рисунок 6.32 Диалоговое окно переключателя режимов      |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_32_switches_mode_dlg.png" style="zoom:80%;" /> |



### 6.12 Настройка IDE.

IDE настраивается в широком диапазоне параметров: можно изменять цвета, разрешение экрана. Настройки конфигурации могут быть доступны через подменю `Environment` в меню `Options`.

#### 6.12.1 Предпочтения.
Диалог настроек вызывается с помощью пункта меню `Options—Environment—Preferences`(Параметры — Среда — Настройки)». Диалог настроек показан на рисунке (6.33).

|          Рисунок 6.33 Диалог настроек предпочтений           |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_33_pref_dlg.png" style="zoom:110%;" /> |


- `Video mode` Раскрывающийся список в верхней части диалогового окна позволяет выбрать режим видео. Доступные режимы видео зависят от системы, в которой работает IDE.
**Примечание**:
    1. Режим видео должен быть выбран нажатием пробела или кликом мыши. Если раскрывающийся список остается раскрытым при выходе из диалогового окна, новый режим видео не будет применяться.
    2. Для DOS версии IDE следует отметить следующее: при использовании режимов VESA частота обновления дисплея может быть очень низкой. На старых графических картах (1998 и ранее) можно использовать драйвер **UniVBE** от **SciTech5** (*прим.перев.*: SciTech Software больше не поддерживает *Display Doctor*, но последняя версия SDD 6.53 доступна [здесь](http://arcadecontrols.com/arcade_downloads.shtml#Drivers)).

- `Desktop File` Указывает, где хранится файл рабочего стола: текущий каталог или каталог, в котором был найден файл конфигурации.
- `Auto save` Здесь можно указать, какие файлы будут сохраняться при запуске программы или при выходе из среды IDE:
    - `Editor files` Будет сохранено cодержимое всех открытых окон редактирования.
    - `Environment` Будут сохранены текущие настройки среды.
    - `Desktop` Будет сохранен файл рабочего стола со всеми настройками рабочего стола (открытые окна, списки истории, точки останова и т.д.).

- `Options` Некоторые особые варианты поведения среды IDE можно указать здесь:
    - `Auto track source`
    - `Close on go to source` Когда этот флажок установлен, окно сообщений закрывается, когда выполняется действие `go to source line`(перейти к исходной строке).
    - `Change dir on open` Когда файл открыт, каталог этого файла становится текущим рабочим каталогом.



#### 6.12.2 Рабочий стол.

Диалоговое окно настроек рабочего стола позволяет указать, какие элементы рабочего стола сохраняются между сеансами, т.е. они сохраняются при выходе из среды IDE и снова восстанавливаются при следующем запуске среды IDE. Они сохраняются в файле `fp.dsk`. Диалоговое окно настроек рабочего стола показано на рисунке (6.34).

|     Рисунок 6.34 Диалоговое окно настроек рабочего стола     |
| :----------------------------------------------------------: |
| <img src="pictures/fig_6_34_dsc_pref_dlg.png" style="zoom:75%;" /> |

Следующие элементы могут быть сохранены и восстановлены в сеансах IDE:

- `History lists` Большинство полей ввода имеют список истории, в котором предыдущие записи сохраняются и могут быть выбраны. Когда этот параметр установлен, эти записи сохраняются в файле рабочего стола. По умолчанию включен.
- `Clipboard content` Если этот флажок установлен, содержимое буфера обмена также сохраняется на диск. По умолчанию выключен.
- `Watch expressions` При установленном флажке все выражения отслеживания сохраняются в файле рабочего стола. По умолчанию выключен.
- `Breakpoints` Если этот флажок установлен, все точки останова с их свойствами сохраняются в файле рабочего стола. По умолчанию выключен.
- `Open windows` Если установлен этот флажок, список файлов в открытых окнах редактора сохраняется в файле рабочего стола, и окна будут восстановлены при следующем запуске IDE. По умолчанию включен.
- `Symbol information` Если этот флажок установлен, информация для браузера символов сохраняется в файле рабочего стола. По умолчанию выключен.
- `CodeComplete wordlist` Если этот флажок установлен, список слов автозавершения кода сохраняется. По умолчанию включен.
- `CodeTemplates` Когда этот флажок установлен, определенные шаблоны кода сохраняются. По умолчанию включен.

**Примечание**: Формат файла рабочего стола изменяется между версиями редактора. Поэтому при установке новой версии может потребоваться удалить файлы `fp.dsk` везде, где их ищет среда IDE.



#### 6.12.3 Редактор.

В этом диалоговом окне можно установить несколько аспектов поведения окна редактора. Диалог настроек редактора показан на рисунке (6.35). Обратите внимание, что некоторые из этих параметров влияют только на вновь открываемые окна, а не на уже открытые (например, вертикальные блоки, выделение столбца/строки).

| Рисунок 6.35 Диалоговое окно настроек окна редактора |
| :--------------------------------------------------: |
|       ![](pictures/fig_6_35_edtr_pref_dlg.png)       |


Следующие элементы могут быть установлены в диалоге настроек редактора:

- `Create backup files` При каждом сохранении файла редактора создается резервная копия старого файла. По умолчанию включен.
- `Insert mode` Начнинать с режима вставки.
- `Auto indent mode` "Умный" отступ включен. Это означает, что нажатие клавиши `Enter` поместит курсор на следующую строку в том же столбце, где текст начинается с текущей строки. По умолчанию включен.
- `Use tab characters` Когда клавиша табуляции нажата, используется символ табуляции. Обычно при нажатии клавиши табуляции вставляются пробелы. Когда эта опция отмечена, вместо нее будут вставлены символы табуляции. По умолчанию выключен.
- `Backspace unindents` Нажатие клавиши `Bksp` приведет к удалению отступа, если будет достигнуто начало текста в текущей строке, вместо удаления только предыдущего символа. По умолчанию включен.
- `Persistent blocks` Когда сделано выделение текста и курсор перемещен, выделение не уничтожается, то есть выделенный блок остается выделенным. По умолчанию включен.
- `Syntax highlight` Используется подсветка синтаксиса для файлов с расширением, которое указывается в списке расширений подсветки. По умолчанию включен.
- `Block insert cursor` Курсор вставки отображается как блок вместо символа подчеркивания. По умолчанию блоком отображается курсор перезаписи. Эта опция полностью изменяет это поведение. По умолчанию выключен.
- `Vertical blocks` При выборе блоков, охватывающих несколько строк, выборка не содержит полных строк в блоке; вместо этого он содержит строки до столбца, на котором находится курсор. По умолчанию выключен.
- `Highlight column` Если этот флажок установлен, текущий столбец (т.е. столбец, в котором находится курсор) выделяется. По умолчанию выключен.
- `Highlight row` При установленном флажке текущая строка (то есть строка, в которой находится курсор) подсвечивается. По умолчанию выключен.
- `Auto closing brackets` Когда вводится символ открывающей скобки, закрывающая скобка также вставляется сразу. По умолчанию выключен.
- `Keep trailing spaces` При сохранении файла пробелы в конце строк удаляются. Эта опция отключает это поведение; то есть любые конечные пробелы также сохраняются в файл. По умолчанию выключен.
- `Codecomplete enabled` Включает автозавершение кода. По умолчанию включен.
- `Enable folds` Включает свертывание кода. По умолчанию выключен.
- `Tab size` Количество пробелов, которые вставляются при нажатии клавиши табуляции. Значением по умолчанию является 8.
- `Indent size` Число пробелов, в которых блок имеет отступ при вызове функции отступа блока. Значением по умолчанию является 2.
- `Highlight extensions` Когда подсветка синтаксиса включена, список масок файлов, введенный здесь, будет использоваться для определения, какие файлы выделены. Маски файлов должны быть разделены точкой с запятой (`;`). По умолчанию это маски `*.pas`; `*.pp`; `*.inc`.
- `File patterns needing tabs` Некоторые файлы (например, `make`-файлы) нуждаются в символах табуляции вместо пробелов. Здесь можно ввести ряд масок файлов, чтобы указать файлы, для которых всегда будут использоваться символы табуляции. По умолчанию это `make*`; `make*.*`.

**Примечание**. Эти параметры не будут применяться к уже открытым окнам; эти опции будут иметь только новые окна.


#### 6.12.4 Клавиатура и мышь.

Диалоговое окно параметров клавиатуры и мыши вызывается пунктом меню `Options—Environment—Keyboard & Mouse`(Параметры — Среда — Клавиатура и мышь). Это позволяет регулировать поведение клавиатуры и мыши, а также чувствительность мыши. Диалоговое окно параметров клавиатуры и мыши показано на рисунке (6.36).

| Рисунок 6.36 Диалоговое окно настроек клавиатуры и мыши |
| :-----------------------------------------------------: |
|     ![](pictures/fig_6_36_kbd_mouse_option_dlg.png)     |

- `Keys for copy, cut and paste` Задает ключи, которые будут использоваться для операций с буфером обмена:

    - Соглашение CUA-91 (`<Shift+Del>`, `<Ctrl+Ins>`, `<Shift+Ins>`)
    - Соглашение Microsoft (`<Ctrl+X>`, `<Ctrl+C>`, `<Ctrl+V>`)

- `Mouse double click` С помощью ползунка можно настроить скорость двойного щелчка. `Fast` означает, что время между двумя щелчками должно быть очень малым; `slow` означает, что время между двумя щелчками мыши может быть довольно продолжительным.
- `Reverse mouse buttons` Поведение левой и правой кнопок мыши можно поменять, установив флажок; это особенно полезно для левшей.
- `Ctrl+Right mouse button` Назначает действие щелчку правой кнопкой мыши с удерживаемой нажатой клавишей `<Ctrl>`.
- `Alt+right mouse button` Назначает действие нажатию правой кнопки мыши с удерживаемой нажатой клавишей `<Alt>`.

Следующие действия могут быть назначены `<Ctrl+Right mouse button>` или `<Alt+right mouse button>`:

- `Nothing` С событие мне связаны никакие действия.
- `Topic search` В указателе справки ищется ключевое слово под курсором мыши.
- `Go to cursor` Программа выполняется до строки, в которой находится курсор мыши.
- `Breakpoint` Задает точку останова в позиции курсора мыши.
- `Evaluate` Посмотреть значение переменной под курсором мыши.
- `Add watch` Добавляет переменную под курсором мыши в список отслеживания.
- `Browse symbol` Символ под курсором мыши отображается в браузере.



### 6.13 Справочная система.

Более подробную информацию о том, как обрабатывать IDE, или об использовании различных вызовов в RTL, а также объяснения синтаксиса операторов Pascal, можно найти в справочной системе. Справочная система активируется нажатием клавиши `<F1>`.


#### 6.13.1 Навигация в справочной системе.

Справочная система содержит гиперссылки; это уязвимые места, которые ведут к другой теме в справочной системе. Они помечены другим цветом. Гиперссылки можно активировать одним из двух способов:

1. непосредственно щелкнув мышью по нужной
2. с помощью клавиш `<Tab>` и `<Shift-Tab>` перемещаться между различными гиперссылками на странице, а затем нажимать клавишу `<Enter>`, чтобы активировать нужную вам ссылку.

При нажатии `<Shift-F1>` отображается содержимое справочной системы. Чтобы вернуться к предыдущему разделу справки, нажмите `<Alt-F1>`. Это также сработает, если окно справки не отображается на рабочем столе; окно помощи будет активировано.


#### 6.13.2 Работа с файлами справки.

В среде IDE есть справочная система, которая может отображать следующие форматы файлов:

- `TPH` Формат справки для просмотра справки `Turbo Pascal`.
- `INF` Формат справки `OS/2`.
- `NG` Формат справки `Norton Guide`.
- `HTML` HTML-файлы.

В будущем может быть добавлено еще несколько форматов. Однако указанные выше форматы должны охватывать уже широкий спектр доступных файлов справки.

**Примечание**: в отношении поддержки файлов HTML следует отметить следующее:

1. Программа просмотра HTML справочной системы ограничена, она может обрабатывать только самые основные файлы HTML (исключая графику), поскольку она предназначена только для отображения файлов справки Free Pascal(*... но не стесняйтесь улучшать его и посылать исправления команде разработчиков Free Pascal ...*).
2. Когда средство просмотра справки HTML встречает графический файл, оно пытается найти файл с тем же именем, но с расширением `.ans`; если этот файл будет найден, он будет интерпретирован как файл с escape-последовательностями ANSI, и они будут использоваться для отображения текстового изображения. Отображение диалоговых окон IDE в файлах справки IDE выполняется следующим образом.

Пункт меню `Help—Files`(Справка - Файлы) позволяет добавлять и удалять файлы справки из списка файлов в оглавлении справки. Диалог файлов справки показан на рисунке (6.37).

| Рисунок 6.37 Диалоговое окно файлов справки |
| :-----------------------------------------: |
|  ![](pictures/fig_6_37_hlp_files_dlg.png)   |


В диалоговом окне перечислены файлы, которые будут представлены в окне оглавления справочной системы. Каждая запись имеет небольшой описательный заголовок и имя файла рядом с ним. При добавлении файлов справки доступны следующие действия:

- `New` Добавляет новый файл. IDE отобразит подсказку, в которой необходимо указать местоположение файла справки. Если добавленный файл является HTML-файлом, отобразится диалоговое окно с запросом заголовка. Этот заголовок будет включен в содержание справки.
- `Delete` Удаляет выделенный в данный момент файл из справочной системы. Он не удаляется с жесткого диска; удаляется только запись справочной системы.
- `Cancel` Отменяет все изменения и закрывает диалог.
- `OK` Сохраняет изменения и закрывает диалог.

Документацию Free Pascal в формате HTML можно добавить в справочную систему IDE. Таким образом, документацию можно просматривать из среды IDE. Если Free Pascal был установлен с помощью установщика, установщик должен был добавить документацию FPC в список файлов справки, если документация также была установлена.

#### 6.13.3 Диалог "О программе".

Диалоговое окно "О программе", доступное через `Help—About...`(Справка - О программе...), показывает некоторую информацию об IDE, такую как номер версии, дата ее создания, какой компилятор и отладчик она использует. При сообщении об ошибках в IDE, пожалуйста, используйте информацию, предоставленную этим диалогом, чтобы определить версию IDE, которая была использована.

Оно также отображает некоторую информацию об авторских правах.



### 6.14 Сочетания клавиш.

Многие сочетания клавиш, используемые в среде IDE, совместимы с `WordStar` и должны быть хорошо известны пользователям `Turbo Pascal`.
Ниже приведены следующие таблицы:

1. В таблице (6.4) перечислены некоторые комбинации клавиш для обработки окон IDE и справки.
2. В таблице (6.5) представлены комбинации клавиш для компиляции, запуска и отладки программы.
3. В таблице (6.6) описаны навигационные клавиши.
4. В таблице (6.7) перечислены ключи редактирования.
5. В таблице (6.8) перечислены все сочетания клавиш блока.
6. В таблице (6.9) представлены все комбинации клавиш, изменяющие выбор.
7. В таблице (6.10) представлены некоторые общие комбинации клавиш, которые не вписываются в предыдущие категории.



**Таблица 6.4: Общая**

| Команда                              | Сочетание клавиш | Альтернативное сочетание клавиш |
| ------------------------------------ | ---------------- | ------------------------------- |
| Справка                              | `F1`             |                                 |
| Перейти к последнему разделу справки | `Alt-F`          |                                 |
| Искать в справке слово под курсором  | `Ctrl-F1`        |                                 |
| Справочный указатель                 | `Shift-F1`       |                                 |
| Закрыть активное окно                | `Alt-F3`         |                                 |
| Увеличить/уменьшить окно             | `F5`             |                                 |
| Переместить/увеличить активное окно  | `Ctrl-F5`        |                                 |
| Переключиться на следующее окно      | `F6`             |                                 |
| Переключиться на предыдущее окно     | `Shift-F6`       |                                 |
| Меню                                 | `F10`            |                                 |
| Местное меню                         | `Alt-F10`        |                                 |
| Список окон                          | `Alt-0`          |                                 |
| Активировать другое окно             | `Alt-<число>`    |                                 |
| Вызвать утилиту `grep`               | `Shift-F2`       |                                 |
| Выход из IDE                         | `Alt-X`          |                                 |



**Таблица 6.5: Компилятор** 

| Команда                                     | Сочетание клавиш | Альтернативное сочетание клавиш |
| ------------------------------------------- | ---------------- | ------------------------------- |
| Сбросить отладчик/программу                 | `Ctrl-F2`        |                                 |
| Показать стек вызовов                       | `Ctrl-F3`        |                                 |
| Запустите до курсора                        | `F4`             |                                 |
| Переключиться на экран пользователя         | `Alt-F5`         |                                 |
| Проследить в                                | `F7`             |                                 |
| Добавить отслеживание                       | `Ctrl-F7`        |                                 |
| Сделать шаг                                 | `F8`             |                                 |
| Установить точку останова на текущей строке | `Ctrl-F8`        |                                 |
| Собрать программу                           | `F9`             |                                 |
| Запустить                                   | `Ctrl-F9`        |                                 |
| Компилировать активный исходный файл        | `Alt-F9`         |                                 |
| Сообщения                                   | `F11`            |                                 |
| Сообщения компилятора                       | `F12`            |                                 |



**Таблица 6.6: Навигация по тексту**

| Команда                                            | Сочетание клавиш      | Альтернативное сочетание клавиш |
| -------------------------------------------------- | --------------------- | ------------------------------- |
| Символ влево                                       | `стрелка влево`       | `Ctrl-S`                        |
| Символ вправо                                      | `стрелка вправо`      | `Ctrl-S`                        |
| Строка вверх                                       | `стрелка верх`        | `Ctrl-E`                        |
| Строка вниз                                        | `стрелка вниз`        | `Ctrl-X`                        |
| Слово влево                                        | `Ctrl-стрелка влево`  | `Ctrl-A`                        |
| Слово вправо                                       | `Ctrl-стрелка вправо` | `Ctrl-F`                        |
| Прокрутка на одну строку вверх                     | `Ctrl-W`              |                                 |
| Прокрутка на одну строку вниз                      | `Ctrl-Z`              |                                 |
| Страница вверх                                     | `PageUp`              | `Ctrl-R`                        |
| Страница вниз                                      | `PageDown`            |                                 |
| Начало строки                                      | `Home`                | `Ctrl-Q-S`                      |
| Конец строки                                       | `End`                 | `Ctrl-Q-D`                      |
| Первая строка окна                                 | `Ctrl-Home`           | `Ctrl-Q-E`                      |
| Последняя строка окна                              | `Ctrl-End`            | `Ctrl-Q-X`                      |
| Первая строка файла                                | `Ctrl-PageUp`         | `Ctrl-Q-R`                      |
| Последняя строка файла                             | `Ctrl-PageDown`       | `Ctrl-Q-C`                      |
| Последняя позиция курсора                          | `Ctrl-Q-P`            |                                 |
| Найти соответствующий разделитель блоков           | `Ctrl-Q-[`            |                                 |
| Найти последний соответствующий разделитель блоков | `Ctrl-Q-]`            |                                 |



**Таблица 6.7: Редактирование**

| Команда                      | Сочетание клавиш | Альтернативное сочетание клавиш |
| ---------------------------- | ---------------- | ------------------------------- |
| Удалить символ               | `Del`            | `Ctrl-G`                        |
| Удалить символ слева         | `Backspace`      | `Ctrl-H`                        |
| Удалить строку               | `Ctrl-Y`         |                                 |
| Удалить до конца строки      | `Ctrl-Q-Y`       |                                 |
| Удалить слово                | `Ctrl-T`         |                                 |
| Вставить строку              | `Ctrl-N`         |                                 |
| Переключить на режим вставки | `Insert`         | `Ctrl-V`                        |



**Таблица 6.8: Команды работы с блоком**

| Команда                                            | Сочетание клавиш | Альтернативное сочетание клавиш |
| -------------------------------------------------- | ---------------- | ------------------------------- |
| Перейти к началу выделенного текста                | `Ctrl-Q-B`       |                                 |
| Перейти к концу выделенного текста                 | `Ctrl-Q-K`       |                                 |
| Выделить текущую строку                            | `Ctrl-K-L`       |                                 |
| Печатать выделенный текст                          | `Ctrl-K-P`       |                                 |
| Выделить текущее слово                             | `Ctrl-K-T`       |                                 |
| Удалить выделенный текст                           | `Ctrl-Del`       | `Ctrl-K-Y`                      |
| Копировать выделенный текст в позицию курсора      | `Ctrl-K-C`       |                                 |
| Переместить выделенный текст в позицию курсора     | `Ctrl-K-V`       |                                 |
| Копировать выделенный текст в буфер обмена         | `Ctrl-Ins`       |                                 |
| Переместить выделенный текст в буфер обмена        | `Shift-Del`      |                                 |
| Отступ блока вправо на один столбец                | `Ctrl-K-I`       |                                 |
| Отступ блока влево на один столбец                 | `Ctrl-K-U`       |                                 |
| Вставить текст из буфера обмена                    | `Shift-Insert`   |                                 |
| Вставить файл                                      | `Ctrl-K-R`       |                                 |
| Записать выбранный текст в файл                    | `Ctrl-K-W`       |                                 |
| Перевести символы текущего блока в верхний регистр | `Ctrl-K-N`       |                                 |
| Перевести символы текущего блока в нижний регистр  | `Ctrl-K-O`       |                                 |
| Перевести символы слова в верхний регистр          | `Ctrl-K-F`       |                                 |
| Перевести символы слова в нижний регистр           | `Ctrl-K-E`       |                                 |



**Таблица 6.9: Изменение выделенного**

| Команда                                                   | Сочетание клавиш            | Альтернативное сочетание клавиш |
| --------------------------------------------------------- | --------------------------- | ------------------------------- |
| Отметить начало выделенного текста                        | `Ctrl-K-B`                  |                                 |
| Отметить конец выделенного текста                         | `Ctrl-K-K`                  |                                 |
| Убрать выделение                                          | `Ctrl-K-Y`                  |                                 |
| Расширить выделение на один символ влево                  | `Shift-стрелка слево`       |                                 |
| Расширить выделение на один символ вправо                 | `Shift-стрелка вправо`      |                                 |
| Расширить выделение до начала строки                      | `Shift-Home`                |                                 |
| Расширить выделение до конца строки                       | `Shift-End`                 |                                 |
| Расширить выделение до того же столбца в последней строке | `Shift-стрелка вверх`       |                                 |
| Расширить выделение до того же столбца в следующей строке | `Shift-стрелка вниз`        |                                 |
| Расширить выделение до конца строки                       | `Shift-End`                 |                                 |
| Расширить выделение на одно слово влево                   | `Ctrl-Shift-стрелка влево`  |                                 |
| Расширить выделение на одно слово вправо                  | `Ctrl-Shift-стрелка вправо` |                                 |
| Расширить выбор на одну страницу вверх                    | `Shift-PageUp`              |                                 |
| Расширить выбор на одну страницу вниз                     | `Shift-PageDown`            |                                 |
| Расширить выделение до начала файла                       | `Ctrl-Shift-Home`           | `Ctrl-Shift-PageUp`             |
| Расширить выделение до конца файла                        | `Ctrl-Shift-End`            | `Ctrl-Shift-PageUp`             |



**Таблица 6.10: Разные команды**

| Команда                   | Сочетание клавиш                   | Альтернативное сочетание клавиш |
| ------------------------- | ---------------------------------- | ------------------------------- |
| Сохранить файл            | `F2`                               | `Ctrl-K-S`                      |
| Открыть файл              | `F3`                               |                                 |
| Поиск                     | `Ctrl-Q-F`                         |                                 |
| Искать снова              | `Ctrl-L`                           |                                 |
| Поиск и замена            | `Ctrl-Q-A`                         |                                 |
| Установить закладку       | `Ctrl-K-n (где n может быть 0..9)` |                                 |
| Перейти к закладке        | `Ctrl-Q-n (где n может быть 0..9)` |                                 |
| Undo(Отмена)              | `Alt-Backspace`                    |                                 |
| Открыть файл под курсором | `Ctrl-Enter`                       |                                 |





# Глава 7.

## Портирование и переносимый код.

### 7.1 Режимы компилятора Free Pascal.

Команда разработчиков Free Pascal пытается создать компилятор, который может скомпилировать как можно больше кода, созданного для компиляторов Turbo Pascal, Delphi или Mac Pascal: это должно обеспечить максимально простое портирование кода, написанного для одного из этих компиляторов.
В то же время разработчики Free Pascal представили множество расширений в языке Object Pascal. Чтобы согласовать эти разные цели и убедиться, что люди могут создавать код, который все еще может быть скомпилирован компиляторами Turbo Pascal и Delphi, у компилятора есть понятие `compiler modes`(режимы компилятора). В определенном режиме компилятор имеет определенные включенные или выключенные функции. Это позволяет ввести режим совместимости, в котором разрешены только те функции, которые поддерживаются оригинальным компилятором. В настоящее время поддерживается 5 режимов:

- `FPC` Это оригинальный режим компилятора Free Pascal: здесь поддерживаются все языковые конструкции, кроме классов, интерфейсов и исключений. В этом режиме поддерживаются объекты. Это режим компилятора по умолчанию.
- `OBJFPC` Это тот же режим, что и режим `FPC`, но он также включает классы, интерфейсы и исключения.
- `TP` Режим совместимости c Turbo Pascal. В этом режиме компилятор пытается максимально близко имитировать компилятор Turbo Pascal. Очевидно, что может быть скомпилирован только 32-битный или 64-битный код.
- `DELPHI` Режим Delphi-совместимости. В этом режиме компилятор старается максимально походить на компилятор Delphi: реализованы большинство функций Delphi 7 и выше.
- `DELPHIUNICODE` Режим Delphi-совместимости. В этом режиме компилятор старается максимально походить на компилятор Delphi: реализованы все функции Delphi 2009 и выше. В этом режиме тип `string` эквивалентен типу `unicode string`.
- `MACPAS` Режим совместимости с Mac Pascal. В этом режиме компилятор пытается разрешить все конструкции, которые реализованы в Mac pascal. В частности, он пытается скомпилировать универсальные интерфейсы.
- `ISO` Стандарт ISO Pascal, режим ISO 7185. В этом режиме компилятор соответствует требованиям уровня 0 и уровня 1 ISO/IEC 7185.
- `ExtendedPascal` Стандартный Extended Pascal, режим ISO 10206. В этом режиме компилятор соответствует требованиям уровня 0 и уровня 1 ISO/IEC 10206.

Режим компилятора может быть установлен отдельно для каждого модуля: каждый модуль может иметь свой собственный режим компилятора, и можно использовать модули, которые были скомпилированы в разных режимах. Режим можно установить одним из двух способов:

1. В командной строке с ключом `-M`.
2. В исходном файле с директивой `{$ MODE}`.

Оба способа принимают имя режима в качестве аргумента. Если исходный файл модуля или программы не указывает режим, используется режим, указанный в командной строке. Если в исходном файле указан режим, он переопределяет режим, указанный в командной строке.
Таким образом, компилируем модуль с ключом `-M` следующим образом:
```bash
fpc -MOBJFPC myunit
```
это то же самое, что иметь следующую директиву mode в модуле:
```pascal
{$MODE OBJFPC}
Unit myunit;
```
Директива `MODE` всегда должна быть расположена перед разделом `uses` интерфейсной части модуля или разделом `uses` программы, поскольку установка режима может привести к загрузке дополнительного модуля в качестве первого загружаемого модуля.

Обратите внимание, что директива `{$ MODE}` является глобальной директивой, то есть она действительна для всего модуля; можно указать только одну директиву.

Режим не влияет на доступность модулей: могут использоваться все доступные модули, независимо от режима, используемого для компиляции текущего модуля или программы.























### 8.7 Программа ppumove.

### 10.2 Использование gdb для отладки вашей программы.

# Приложение A

## Алфавитный список параметров командной строки

