# Firebird 3.0.7 Release Notes
Firebird Project: Core Developers **Helen Borrie**
Version 0307-01, 15 October 2020

## 1. Общие замечания

Оригинальный текст [здесь](https://firebirdsql.org/file/documentation/release_notes/html/en/3_0/rlsnotes30.html#rnfb30-general)

## 2. Новое в Firebird 3.0

Основной целью Firebird 3 были унификация серверной архитектуры и улучшение поддержки SMP и многоядерных аппаратных платформ. Параллельные цели заключались в улучшении потоковой передачи процессов движка и возможностей совместного использования кэша страниц через границы потоков и соединений.

Наряду с этими целями появились новые стратегии повышения производительности, оптимизации запросов, мониторинга и масштабируемости, а также удовлетворения спроса на дополнительные параметры безопасности. В язык SQL был введен ряд популярных функций, включая долгожданную поддержку типа данных BOOLEAN и связанных с ним логических выражений.

### Субрелизы

Подробные сведения об улучшениях и ссылки на исправления ошибок в дополнительных выпусках можно найти в главе [Общие замечания](https://firebirdsql.org/file/documentation/release_notes/html/en/3_0/rlsnotes30.html#rnfb30-general).

### Вкратце о функциях

В следующем списке перечислены функции и изменения со ссылками на главы и темы, где можно найти более подробную информацию.

#### Завершение унификации исполняемого файла Firebird

После завершения настоящей поддержки SMP для *Superserver* ядро Firebird теперь представляет собой унифицированную библиотеку, которая поддерживает один ODS, загружаемый либо как встроенный механизм, либо исполняемый файл «сетевого слушателя». Выбор модели сервера определяется настройками нового параметра конфигурации `ServerMode`, определяющего режимы блокировки и кеширования. Он указывается на глобальном уровне в *firebird.conf*.

По умолчанию `ServerMode = Super` (псевдоним `ThreadedDedicated`), то есть *SuperServer*.

​	<img src="D:\Archive\github\translations\release_note_firebird_307\pictures\Picto-info.png" style="zoom:25%;" />	| Файл *aliases.conf* из предыдущих версий заменен на *databases.conf*, теперь он включает не только псевдонимы для баз данных, но также (необязательно) параметры конфигурации, позволяющие индивидуально настраивать базы данных и/или альтернативные базы данных безопасности.

Более подробно изменения описаны в главе [Изменения в движке Firebird](##3.-Изменения-в-движке-Firebird).

#### Настоящая поддержка SMP для SuperServer

В режиме *Superserver* движок теперь использует несколько процессоров и ядер при создании соединений.

Трекер: [CORE-775](http://tracker.firebirdsql.org/browse/CORE-775)

Реализовано В. Хорсуном

#### Новые, объектно-ориентированные C++  API

Объектно-ориентированные C++ API позволяют подпрограммам внешнего кода подключаться и безопасно работать в пространстве ядра Firebird, включая (но не ограничиваясь):

- Схемы шифрования данных

- Схемы аутентификации пользователей, включая безопасный обмен ключами

- В итоге, подключаемый модуль поддерживает хранимые процедуры, триггеры и функции, написанные на Java, C++, ObjectPascal и т.д.

#### Конфигурация “Per-database”

[Пользовательская конфигурация на уровне базы данных](###Конфигурация-“Per-database”) теперь может быть достигнута с помощью формальных записей в *databases.conf* (ранее *aliases.conf*).

#### Увеличенные лимиты в нескольких областях

Для идентификаторов транзакций, идентификаторов вложений и операторов увеличены максимальные значения.

Максимальное количество буферов страниц в кеше увеличено для 64-битных серверов.

Увеличен максимальный размер базы данных.

Дополнительные сведения см. в главе 4, [Изменения в API и ODS](##4.-Изменения-в-API-и-ODS).

#### Несколько баз данных безопасности

Firebird теперь поддерживает управление доступом пользователей через несколько баз данных безопасности на сервере. Каждую базу данных можно настроить с помощью параметра `SecurityDatabase` в файле *databases.conf* для использования конкретной базы данных, отличной от *security3.fdb* по умолчанию. Пользовательские структуры могут быть определены даже в самой пользовательской базе данных.
​	<img src="D:\Archive\github\translations\release_note_firebird_307\pictures\Picto-info.png" style="zoom:25%;" />	|Флаг `MON$SEC_DATABASE` был добавлен в таблицу мониторинга `MON$DATABASE`, чтобы помочь определить, какой тип базы данных безопасности используется - **Default**, **Self** или **Other**.

#### Несколько новых команд SQL для управления пользователями и доступом

Изменения в архитектуре, ужесточение правил безопасности и целостности данных, а также запросы функций привели к появлению множества новых [команд SQL для управления пользователями и их доступом к объектам](####Управление-пользователями-на-основе-SQL).

#### Международные символы в учетных данных пользователя

При использовании новых условий аутентификации система может принимать имена пользователей и пароли, содержащие символы, отличные от ASCII. См. [Международные наборы символов для учетных записей пользователей](###Международные-наборы-символов-для-учетных-записей-пользователей) в главе [Безопасность](##7.-Безопасность).

#### Поддержка нового типа данных

**BOOLEAN**
    Истинный тип `BOOLEAN` (*True*/*False*/*Unknown*) с поддержкой логических предикатов, например,

```sql
UPDATE ATABLE
  SET MYBOOL = (COLUMN1 IS DISTINCT FROM COLUMN2)
```
Подробнее см. [тип BOOLEAN](#####Тип-данных-BOOLEAN).

**IDENTITY**
    Тип `IDENTITY`, порождающий уникальные идентификаторы для определенного столбца из внутреннего генератора. Подробнее см. [cтолбец в стиле IDENTITY](#####Столбец-Identity-Type).

#### Управление атрибутом столбца/домена NULL/NOT NULL

Атрибутом `NOT NULL` для столбца или домена теперь можно управлять с помощью синтаксиса `ALTER TABLE` или `ALTER DOMAIN` соответственно. Дополнительные сведения см. в разделе [Управление возможностью об-null-ения в доменах и столбцах](####Управление-возможностью-об-null-ения-в-доменах-и-столбцах).

#### Поддержка пакетов SQL

Подробнее см. [Пакеты](###Пакеты).

#### DDL-триггеры

Теперь можно написать триггеры для выполнения при изменении или удалении объектов базы данных. Типичное использование - блокировать выполнение этих задач неавторизованными пользователями.

Подробнее см. [Триггеры DDL](###DDL-триггеры).

#### 'Оконные' функции в DML

Совершенно новая серия аналитических функций для работы с несколькими подмножествами в DML. См. [Оконные (аналитические) функции](###Оконные-(аналитические)-функции).

#### Статистические функции

Набор статистических функций, возвращающих значения для различных формул дисперсии, стандартного отклонения и линейной регрессии. См. [Статистические функции](####Статистические-функции).

#### Прокручиваемые курсоры

Механизм запросов теперь поддерживает двунаправленные («прокручиваемые») курсоры, обеспечивая как прямую, так и обратную навигацию в PSQL и DSQL с поддержкой API. См. раздел [Поддержка прокручиваемого (двунаправленного) курсора](###Поддержка-прокручиваемого-(двунаправленного)-курсора).

#### SQL:2008 совместимые операторы OFFSET и FETCH

Реализована поддержка операторов `OFFSET` и `FETCH`, совместимых с SQL-2008, в качестве альтернативы операторам {`FIRST` и `SKIP`} или {`ROWS` и `TO`}. См. [SQL-2008 совместимые операторы OFFSET и FETCH](####SQL-2008-совместимые-операторы-OFFSET-и-FETCH).

#### Поддержка IPv6

Firebird 3 может использовать IPv6-соединения как на стороне клиента, так и на стороне сервера. См. примечания к новому параметру конфигурации [IPv6V6Only](####IPv6V6Only).

#### Валидация базы данных, находящейся в режиме онлайн

Оперативная проверка, впервые реализованная в Firebird 2.5.4, перенесена на Firebird 3.0. См. раздел [Работа некоторых служб валидации в режиме онлайн](#####Работа-некоторых-служб-валидации-в-режиме-онлайн)

#### Статистика времени выполнения в подробном выводе gbak

Подробный вывод из *gbak* теперь может включать [статистику времени выполнения](####Статистика-времени-выполнения-в-подробном-выводе), истекшее время вывода лога, чтение и запись страниц. Также поддерживается в [службе API](#####SPB-поддержка-новой-функции-статистики-в-выводе-gbak).

### Совместимость со старыми версиями

Ряд замечаний о совместимости со старыми версиями Firebird собран в главе 12 [«Проблемы совместимости»](##12.-Проблемы-совместимости). Включены инструкции по [инициализации базы данных безопасности](###Инициализация-базы-данных-безопасности), если это не было сделано вашим установочным комплектом, и по настройке сервера для [устаревшего способа аутентификации](###Устаревший-способ-аутентификации).



## 3. Изменения в движке Firebird

В Firebird 3 модернизация архитектуры, начатая в v.2.5, завершилась внедрением полной SMP-поддержки для модели *Superserver*. В новой схеме можно настроить исполняемую модель индивидуально для каждой базы данных.

### Модернизированная архитектура
*Дмитрий Еманов*

Модернизированная архитектура объединяет ядро движка для моделей *Classic*/*Superclassic*, *Superserver* и *embedded* в общий двоичный файл. Поведение кэша и блокировки, которое различает исполняемые модели, теперь определяется внешними настройками в новом параметре конфигурации `ServerMode`. Метод подключения определяется порядком и содержимым другого параметра, `Providers` и [протокола подключения](###Строка-подключения-и-протоколы), который задается во время выполнения строкой подключения, предоставляемой, когда клиент запрашивает подключение.

Параметры для настройки архитектуры указываются глобально (в *firebird.conf*). Провайдеры могут быть переопределены специально для базы данных (в *databases.conf*).

​	<img src="D:\Archive\github\translations\release_note_firebird_307\pictures\Picto-info.png" style="zoom:25%;" />	|*Database.conf* - это старый *aliases.conf* из предыдущих версий с новым именем. В Firebird 3 роль этого файла включает (потенциально) гораздо больше, чем просто поиск путей к файлам базы данных. Дополнительные сведения о том, что можно настроить на уровне базы данных, см. в главе [«Дополнения и изменения конфигурации»](##6.-Дополнения-и-изменения-конфигурации).



### Режимы сервера

| Режим сервера | Синоним           | Модель ресурсов                                              | Провайдер(ы)                   |
| ------------- | ----------------- | ------------------------------------------------------------ | ------------------------------ |
| Super         | ThreadedDedicated | База данных открывается исключительно одним серверным процессом. Пользовательские подлючения обрабатываются потоками, запускаемыми из общего пула, и все они используют общий кеш страниц базы данных внутри процесса. *Это установка по умолчанию*. | Remote, Engine12[^1], Loopback |
| SuperClassic  | ThreadedShared    | Базы данных открываются одним серверным процессом, но доступ не является исключительным: встроенный процесс может одновременно открывать одну и ту же базу данных. Пользовательские подключения обрабатываются потоками, запускаемыми из общего пула, каждый из которых имеет свой собственный кеш страниц базы данных. | Remote, Engine12, Loopback     |
| Classic       | MultiProcess      | Для каждого подключения к серверу запускается отдельный процесс. База данных может быть открыта несколькими процессами Classic, включая локальные процессы для встроенного доступа. Каждый процесс имеет свой собственный кеш страниц базы данных. | Remote, Engine12, Loopback     |

[^1]: Только при наличии эксклюзивного доступа



### Провайдеры

Провайдеры - это более или менее то, что мы традиционно считали методами, используемыми для подключения клиента к серверу, то есть через сеть, локально на хосте, через локальную петлю («localhost») или более прямое локальное соединение (старый *libfbembed.so* в POSIX, теперь реализованный как библиотека подключаемых модулей *libEngine12.so*; в Windows - *engine12.dll*; в MacOSX - *engine12.dylib*).
- в *firebird.conf* все они доступны по умолчанию, а именно:
```bash
#Providers = Remote,Engine12,Loopback
```

- в *database.conf* можно заблокировать одного или нескольких провайдеров, вставив строку из *firebird.conf*, раскомментировав ее и удалив нежелательного(ых) провайдера(ов).



#### Архитектура провайдеров

*Алекс Пешков*

Архитектура провайдеров, хотя и является ключевой особенностью Firebird 3, не нова. Провайдеры исторически существовали в предшественниках Firebird и, хотя и хорошо скрыты, присутствуют во всех предыдущих версиях Firebird. Первоначально они были введены для решения задачи, которая с тех пор выполнялась «уровнями интерфейса», такими как ODBC, ADO, BDE и т.п., для обеспечения доступа к различным ядрам баз данных с использованием единого внешнего интерфейса.

Впоследствии эта архитектура провайдеров (известная тогда как реляционный интерфейс открытых систем, OSRI) также зарекомендовала себя как очень эффективная для поддержки сочетания старых и новых форматов баз данных - различных основных версий дисковой структуры - на одном сервере, имеющем смешанные подключения к локальным и удаленным базам данных.

Провайдеры, реализованные в Firebird 3, позволяют поддерживать все эти режимы (удаленные соединения, базы данных с разными ODS, сторонние движки), а также объединение провайдеров в *цепочку*. Цепочка - это термин для ситуации, когда провайдер использует обратный вызов стандартного API при выполнении операции с базой данных.



#### Компоненты

Основным элементом архитектуры провайдеров является Y-образный клапан (y-valve). При первоначальном подключении или вызове создания базы данных y-valve просматривает список известных провайдеров и вызывает их одного за другим, пока один из них не завершит запрошенную операцию успешно. Для уже установленного соединения сразу вызывается соответствующий провайдер с почти нулевыми накладными расходами.

Давайте посмотрим на некоторые примеры работы y-valve, когда он выбирает подходящего поставщика на этапе соединения (attach). Он используют конфигурацию по умолчанию, которая содержит трех провайдеров:

- Remote (установливает сетевое соединение)
- Engine12 (основной движок базы данных)
- Loopback (принудительное сетевое соединение с локальным сервером для <имени базы данных> без предоставления явного сетевого протокола)

Типичная конфигурация клиента работает следующим образом: когда кто-то подключается к базе данных с вызовом `RemoteHost:dbname` (синтаксис TCP/IP) или `\\RemoteHost\dbname` (NetBios), `Remote` провайдер обнаруживает явный [синтаксис сетевого протокола](###Строка-подключения-и-протоколы) и, найдя его сначала в списке провайдеров, перенаправляет вызов `RemoteHost`.

Когда <имя базы данных> содержит не сетевой протокол, а только имя базы данных, `Remote` провайдер отклоняет его, а провайдер `Engine12` выходит на первый план, пытаясь открыть указанный файл базы данных. В случае успеха мы получаем встроенное (*embedded*) соединение с базой данных.

​	<img src="D:\Archive\github\translations\release_note_firebird_307\pictures\Picto-info.png" style="zoom:25%;" />	|Специальная «встроенная(*embedded*) библиотека» больше не требуется. Чтобы установить встроенное соединение, стандартный клиент загружает соответствующего провайдера и становится встроенным сервером.


##### **Реакция на отказ**

Но что произойдет, если движок вернет ошибку при попытке подключения к базе данных?

- Если файл базы данных, к которому нужно подключится, не существует, нет никакого интереса.

- Встроенное соединение может завершиться ошибкой, если у подключающегося к нему пользователя недостаточно прав для открытия файла базы данных. Это было бы нормальным, если б база данных не была создана этим пользователем в *embedded*-режиме или если б пользователю явно не были предоставлены права ОС для встроенного доступа к базам данных на этой машине.

​	<img src="D:\Archive\github\translations\release_note_firebird_307\pictures\Picto-info.png" style="zoom:25%;" />	|Такая установка прав доступа является требованием для правильной работы Суперсервера.

- После того, как `Engine12` не смог получить доступ к базе данных, пытается подключиться провайдер `Loopback`. Он не сильно отличается от `Remote`, за исключением того, что он пытается получить доступ к базе данных с именем <dbname> на сервере, на котором запущен локальная петля TCP/IP.

На Windows сначала проверяется `XNET`, затем локальная петля `TCP/IP` (с добавлением `localhost:` перед именем базы данных), затем локальная петля именованных каналов `Named Pipes (NetBEUI)` (с добавлением `\\.\`). Сервер может быть запущен с отключенным XNET (или любым другим протоколом), поэтому мы пробуем все варианты. В POSIX поддерживается только протокол `TCP/IP`, другие параметры недоступны.

Если подключение завершается успешно, устанавливается удаленное соединение с базой данных, даже если она находится на локальном компьютере.

#### Другие провайдеры

Использование провайдеров не ограничивается тремя стандартными. Firebird 3 не поддерживает базы данных до ODS 12. Удаление поддержки старых форматов из движка помогает упростить его код и немного прибавить скорости. Принимая во внимание, что это увеличение скорости иногда происходит в критических для производительности местах, например, при поиске ключа в блоке индексов, избегание старого кода и связанных ветвей действительно заставляет Firebird летать быстрее.

Тем не менее, архитектура провайдеров позволяет получить доступ к старым базам данных при переходе на более новую версию Firebird. Подходящий провайдер может быть рассмотрен для включения в более позднюю версию.

##### **Пользовательский провайдер**

Сильная особенность архитектуры провайдеров - возможность для развертывающего  приложение добавлять своих собственных провайдеров на сервер, на клиент или на того и другого одновременно.

Так что еще может понадобиться клиенту, кроме удаленного подключения? Вспомните цепочку провайдеров, о которой говорилось ранее. Представьте себе ситуацию, когда доступ к базе данных осуществляется через очень медленное сетевое соединение, скажем, что-то вроде 3G или, того хуже, GPRS. В качестве способа его ускорения приходит на ум кэширование - на клиенте - некоторых больших таблиц, которые редко меняются. Такие системы действительно были реализованы, но для этого пришлось переименовать *fbclient* во что-то произвольное и загрузить ее в свою собственную библиотеку под названием *fbclient*, что позволило использовать стандартные инструменты для доступа к базе данных одновременно с кешированием необходимых таблиц. Это работает, но как решение явно не идеально.

В архитектуре провайдеров вместо переименования библиотек просто добавляется локальный провайдер кэширования, который может использовать любой метод для обнаружения подключений к нему (что-то вроде префикса `cache@` в начале имени базы данных или как угодно еще по вашему выбору).

В этом примере, когда используется базы данных с именем `cache@RemoteHost:dbname`, провайдер кэширования принимает соединение и еще раз вызывает  y-valve с традиционным именем базы данных `RemoteHost:dbname`. Когда пользователь позже выполняет любой вызов своей базы данных, провайдер кэширования получает контроль над ней до того, как это сделает `Remote`, и для локально кэшированной таблицы может предотвратить вызовы удаленного сервера.

Использование цепочки позволяет реализовать много других полезных вещей. Примером может быть репликация в стиле MySQL на уровне операторов без необходимости в триггерах: просто повторите те же вызовы для хоста репликации, возможно, когда транзакция закоммичена. В этом случае провайдер цепочки будет установлен на сервере, а не на клиенте, и никакая модификация командной строки не потребуется.

​	<img src="D:\Archive\github\translations\release_note_firebird_307\pictures\Picto-info.png" style="zoom:25%;" />	|Тем не менее, репликация на уровне операторов - очень сомнительная функция.

Чтобы избежать зацикливания при выполнении обратного вызова y-valve во время коннекта, такой провайдер может изменить список провайдеров с помощью параметра `isc_dpb_config` в DPB. Эту же технику можно использовать и у клиента.

Подробнее см. в главе [«Дополнения и изменения конфигурации»](##6.-Дополнения-и-изменения-конфигурации).

Также не следует упускать из виду возможность доступа к сторонним движкам баз данных с помощью провайдеров. Это может показаться странным, учитывая количество инструментов, доступных для такого рода задач. Подумайте о возможности доступа к другим базам данных Firebird с помощью `EXECUTE STATEMENT`, который стал доступен в *Firebird 2.5*. Посредством провайдера *ODBC* или другого распространенного инструмента для доступа к различным источникам данных, можно использовать `EXECUTE STATEMENT`, чтобы получить прямой доступ из процедур и триггеров к данным из любой базы данных, имеющей драйвер для выбранного инструмента доступа. Возможно даже иметь провайдера для доступа к некоторому определенному типу механизма внешней базы данных, если есть какая-то причина, по которой следует избегать уровня *ODBC*.

##### **Провайдеры: вопрос-ответ**

1. *Интерфейсы и провайдеры, вероятно, очень хороши, но у меня есть старая задача, написанная с использованием простых функций API, и по многим причинам я не могу ее переписать в ближайшем будущем. Значит ли это, что у меня возникнут проблемы при переходе на Firebird 3?*

Однозначно никаких проблем. Старый API поддерживается для обратной совместимости в Firebird 3 и будет поддерживаться в будущих версиях до тех пор, пока людям это нужно.

2. *А как насчет производительности при использовании старого API?*

Функционал API реализован как очень тонкий слой поверх интерфейсов. Код в большинстве случаев тривиален: преобразовать переданные дескрипторы в указатели на интерфейсы - до сих пор это называлось «валидацией дескрипторов» - и вызывать соответствующую функцию из интерфейса.

Функции, которые выполняют операцию SQL и извлекают из нее данные, - это то место, где кодирование немного сложнее, включая конструкцию SQLDA. Перемещение данных, связанное с SQLDA, всегда создавало накладные расходы. Логика между новым и старым API не увеличивает существенно эти старые накладные расходы.

### Строка подключения и протоколы

*Строка подключения* относится к локальному или удаленному пути к базе данных, к которой клиент запрашивает подключение (соединение). Синтаксис строки подключения определяет транспортный протокол, по которому взаимодействуют клиенты и сервер. Устаревшие синтаксисы для доступных протоколов, поддерживаемые всеми версиями Firebird, следующие:

**Для протокола TCP/IP (он же INET)**
```sql
<host> [ / <port>] : <путь к файлу базы данных или псевдоним>
```

**Протокол для именованных каналов *named pipes* (он же NetBEUI, он же WNET)**
```sql
\\ <host> [ @ <port>] \ <путь к файлу базы данных или псевдоним>
```

**Для локальных подключений просто**
```sql
<путь к файлу базы данных или псевдоним> ....
```

Если `host` не указан, подразумевается локальное соединение. В зависимости от настроек, платформы и версии Firebird, это может быть выполнено через `embedded` движок, протокол `XNET` (разделяемая память) или TCP/IP по локальной петле `localhost`.

##### **Примеры**

**Подключение через TCP/IP, используя имя базы данных**
```sql
192.168.0.11:/db/mydb.fdb
192.168.0.11:C:\db\mydb.fdb
myserver:C:\db\mydb.fdb
localhost:/db/mydb.fdb
```

**Подключение через TCP/IP с использованием псевдонима базы данных**
```sql
192.168.0.11:mydb
myserver:mydb
localhost:mydb
```

**Подключение через TCP/IP с использованием нестандартного порта 3051
```sql
192.168.0.11/3051:C:\db\mydb.fdb
192.168.0.11/3051:mydb
myserver/3051:/db/mydb.fdb
localhost/3051:/db/mydb.fdb
myserver/3051:mydb
localhost/3051:mydb
```

**Подключение через TCP/IP, используя нестандартное имя службы
```sql
192.168.0.11/fb_db:C:\db\mydb.fdb
192.168.0.11/fb_db:mydb
localhost/fb_db:/db/mydb.fdb
myserver/fb_db:/db/mydb.fdb
myserver/fb_db:mydb
localhost/fb_db:mydb
```

** Подключение через именованные каналы Named Pipes (только для Windows)
```sql
\\myserver\C:\db\mydb.fdb
\\myserver@fb_db\C:\db\mydb.fd
```

**Локальное соединение
```sql
/db/mydb.fdb
C:\db\mydb.fdb
mydb
```

#### Строки подключения в URL-стиле

Firebird 3.0 представляет дополнительный обобщенный синтаксис в URL-стиле для строк подключения. Шаблон такой:
```sql
[ <protocol> : // [ <host> [ : <port> ] ] ] / <путь к файлу базы данных или псевдоним>
<protocol> ::= INET | WNET | XNET
```

*Прим.переводчика: в официальной документации допущена ошибка для WNET-протокола. "Правильная" строка коннекта должна выглядеть следующим образом:
```sql
[  <protocol> : //\\ [host [ @ <port> ] ] ] / <путь к файлу базы данных или псевдоним>
<protocol> ::= WNET
```






















## 4. Изменения в API и ODS

### Интерфейсы прикладного программирования (API)
#### Улучшения API
##### **SPB поддержка новой функции статистики в выводе gbak**
##### **Работа некоторых служб валидации в режиме онлайн**

## 6. Дополнения и изменения конфигурации
### Конфигурация “Per-database”
### Новые параметры
#### IPv6V6Only

## 7. Безопасность


### Международные наборы символов для учетных записей пользователей
### Функции SQL для управления доступом
#### Управление пользователями на основе SQL

## 8. Язык определения данных (DDL)
### Быстрые ссылки
### Улучшения DDL

В лексикон языка определения данных SQL были добавлены следующие усовершенствования:

#### Новые типы данных

В этом релизе представлен полноценный тип `BOOLEAN` вместе с поверхностной эмуляцией стандартного столбца “identity” SQL.

##### Тип данных BOOLEAN

Adriano dos Santos Fernandes

##### Столбец Identity Type

#### Управление возможностью об-null-ения в доменах и столбцах

## 9. Язык манипулирования данными (DML)

### Оконные (аналитические) функции

### Внутренние функции

#### Статистические функции

### Улучшения DML

#### SQL-2008 совместимые операторы OFFSET и FETCH



## 10. Процедурный SQL (PSQL)

### Пакеты

### DDL-триггеры

### Поддержка прокручиваемого (двунаправленного) курсора

#### Синтаксис курсора для PSQL

## 11. Мониторинг и утилиты командной строки

### gbak

#### Статистика времени выполнения в подробном выводе

## 12. Проблемы совместимости
### Инициализация базы данных безопасности
### Устаревший способ аутентификации